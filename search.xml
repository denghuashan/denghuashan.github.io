<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[坦克大战的实现]]></title>
    <url>%2F2021%2F07%2F08%2Ftank-game%2F</url>
    <content type="text"><![CDATA[很早期时写过的代码了，花了一个多星期的时间才写出这个坦克大战。有点小意思，所以想用文字的方式复述一下当时完成这个小游戏过程，以及当时遇到的一些困难。 效果演示 设计思路从整个坦克大战的游戏所拥有的元素进行思考，需要哪些对象来支持。主要元素：1、坦克2、炮弹次要元素：1、开始按钮、开始页、游戏地图。游戏流程：1、1个坦克一次不能发出超过5个炮弹。2、坦克不能开出地图。3、炮弹打中己方无效，打中敌方，敌方消失。4、坦克之间的行进，不能重叠。 类图 流程图主要的核心点，在于使用Thread，产生子线程，并使各个子线程间进行相互通信。因run()的返回值是void类型，所以也使用了单例中的懒汉式，方便拿到各个子线程，对其进行控制。 主要代码MyPanel EnemyTank Bullet ShareData 线程消耗 FutureTaskFutureTask是JDK1.5以后concurrent包中的类。之所以想写这个，是因为在没看源码之前，使用FutureTask，它居然能有返回值。百思不得其解，明明Thread的run()是void类型，为何使用FutureTask居然有返回值，难道JDK1.5之后关于线程，重新写了。直到看了源码以后，发现FutureTask的run()，其实跟我写的这个小游戏，线程之间产生通信的方式，思想都是相通的。在执行Callable的call()函数后，把返回值存了起来。而存起来的方式，是在FutureTask中定义了一个类型为Object的成员变量outcome进行接收，而在get()函数中，对outcome按泛型的具体类型进行强转进行返回。 而在坦克大战中，坦克、子弹能够消亡，也是在类中定义了一个boolean类型的成员变量run，来控制线程的执行。一旦触发相应的逻辑时，通过ShareData拿到对应的线程实例，把该线程实例中的成员变量run置位false，让该线程消亡。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[年年岁岁，岁岁年年（2020）]]></title>
    <url>%2F2021%2F02%2F04%2Flook-back-2020%2F</url>
    <content type="text"><![CDATA[年年岁岁，岁岁年年岁岁年年，是时候回顾这一年的经历了。生活不易，疫情常在，全民抗疫，成为今年常谈的话题。既有为那些逆行者的感动、敬佩；又有为张桂梅从改变一个人到影响三代人的肃然起敬。可能是老了，越见不得，也越听不得这种感人肺腑的事迹，一见一听，保证鼻子发酸。活久见，诚如股神巴菲特，对美股熔断今年都是活久见，更何况似我们这类凡夫俗子。第一次经历如此可怕的疫情，第一次经历如此长久的假期。如果要对2020年做一个总结，只想说，平淡才是真。感恩国家的强大，感恩身边人都平平安安。 2021The limits of your world are the limits of your language!2021，勇往直前。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2021年月度目标与进展]]></title>
    <url>%2F2020%2F12%2F31%2Fannual-summary-2021%2F</url>
    <content type="text"><![CDATA[1月目标 复习《高等数学-工本》 完成《新概念英语-二》的学习 阅读《影响商业的50本书》 已完成 《新概念英语-二》的学习 《高等数学-工本》 未完成 阅读《影响商业的50本书》 2月目标 复习《高等数学-工本》 阅读《影响商业的50本书》 已完成 复习《高等数学-工本》 未完成 阅读《影响商业的50本书》 3月目标 复习《高等数学-工本》 阅读《影响商业的50本书》 未完成 复习《高等数学-工本》 阅读《影响商业的50本书》 4月目标 复习《高等数学-工本》 参加考试《高等数学-工本》 已完成 复习《高等数学-工本》 5月目标 《深入理解Java虚拟机》 未完成 《深入理解Java虚拟机》 已完成 《高等数学-工本》已通过 6月目标 《深入理解Java虚拟机》 《Spring Cloud微服务实战》 未完成 《深入理解Java虚拟机》 《Spring Cloud微服务实战》 已完成 《深入理解Java虚拟机》 7月目标 《Spring Cloud微服务实战》]]></content>
      <categories>
        <category>随想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2020年月度目标与进展]]></title>
    <url>%2F2019%2F12%2F31%2Fannual-summary-2020%2F</url>
    <content type="text"><![CDATA[1月目标 自学教材《高等数学-工专》 复习《计算机网络管理》 再读《深入理解Java虚拟机》 阅读《经济学通识》 阅读《你有你的计划，世界另有计划》 已完成 自学教材《高等数学-工专》 未完成 复习《计算机网络管理》 再读《深入理解Java虚拟机》 阅读《经济学通识》 阅读《你有你的计划，世界另有计划》 2月目标 自学教材《高等数学-工本》 复习《计算机网络管理》 阅读《经济学通识》 阅读《你想活出怎样的人生》 未完成 自学教材《高等数学-工本》 复习《计算机网络管理》 阅读《经济学通识》 阅读《你想活出怎样的人生》 3月目标 自学教材《高等数学-工本》 复习《计算机网络管理》]]></content>
      <categories>
        <category>随想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[再见，2019]]></title>
    <url>%2F2019%2F12%2F31%2Flook-back-2019%2F</url>
    <content type="text"><![CDATA[即将消逝的20192019即将消逝，回顾这一年的生活，过得很迷糊。个人阶段性的目标很发散，执行起来，效率较低。碌碌无为，指的就是我这种人。第一季度忙着备考，补充吴晓波所写的经济类相关知识。如果真要谈论收获，大抵都是些自欺欺人式的收获。比方说看待问题的发展，预测问题的走势。真要说有用，我也看不出来。第二季度忙着写论文，与其说忙，不如说是在打渔。时间是被消磨掉的。第三季度，忧心忡忡，心绪难宁。工作，学习，生活，考试，感觉快要被逼疯。第四季度，迷失中的自我，非常不喜欢这种感觉。我该如何让自己逃脱出来？整个2019出现在脑海中频率较高的词有：政策、系统化、刻意练习。关于政策这个词，国家所颁布的一些政策纲领文件，它都对国民生活产生巨大影响。从吴晓波所写的书里面，真实的感受到经济政策对国民经济的巨大刺激作用，同时确实有那么一批人能够从这些经济政策中嗅到财富的气味，同时抓住一波又一波的先机。后知后觉，在这些政策中是很可怕的。一定要看第一手的政策资料，逐行逐句的看，一句一句的去想是什么含义。这样才不会被别人带偏你的思维方式与理解。关于系统化，可能是比较关注的几个人物提到过几次，所以让自己一直在想，什么是知识点，什么是系统化。具体点就是，背过乘法口诀的，都知道5乘以6等于30，这个5X6=30，其实就是一个知识点。再具体一点，在商店买了5瓶可乐，每瓶刚好6块钱，这时可以用乘法口诀5X6=30，算出来需要支付30元。用一个知识点，解决了实际场景中的某个问题。或者遇到某个问题时，你刚好知道能够用哪个知识点来解决或解答这个问题。属于一个整体中的部分，而不再是让知识点单一的存在。这就是我所理解的系统化，较为肤浅。关于刻意练习，之前看过《刻意练习》，感触不深。考试很累，背书也累，还经常背了就忘。所以一直很好奇那些考神，为什么考试特别厉害，分数那么高。挺逗的一件事情是在11月参加软考，在草稿纸上写了一句话，奋笔疾书是一种什么样的感觉？说实话，我至今都没找到过这种感觉。所以在想怎样让自己记得更牢固，刻意练习又讲的是什么。应该是对自己不熟悉的知识点，进行重复。这种重复应该还是刻意的，发现自己对某个知识点生疏了，再重复的练习一下，成为一个熟练工。刻意，所谈论的应该是一种主动性，而不是被动。 2020的期许I’m brave!愿2020，考神附体。再见，2019！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL上表分区的试验]]></title>
    <url>%2F2019%2F07%2F24%2Fmysql-partition%2F</url>
    <content type="text"><![CDATA[问题描述生产库上关注表（focus），目前单表数据量级去到了1600w条。但很多是无效的数据，实际有用的数据是半年。通过分区的方式来优化这个表，加速数据查询速度。 操作过程思路新建一张分区表，以flg_date字段来进行分区选择，以一个季度的数据分一个区。然后把旧表的数据导入到新表，修改旧表表名，再把新表改回旧表的名字。以flg_date字段进行分区，在DAO层的查询中，select共出现18次，查询条件带flg_date的，出现9次。 试验环境（虚拟机）mysql版本：5.6.40操作系统：Linux CentOS-7.0内存：1G内核：1硬盘：20G 创建分区表（csmbp_flight_focus_p）因默认分区限制分区字段必须是主键（PRIMARY KEY)的一部分，需要把id 、flt_date一起设为该表主键，使用联合主键。focus表结构中，有7个索引，1个主键索引，一个普通索引，5个组合索引，新建的分区表，暂不加入旧表中的索引。按季度分区，一次分十年。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455CREATE TABLE `focus_p` ( `id` varchar(64) NOT NULL, `flt_date` datetime NOT NULL, PRIMARY KEY (`id`, `flt_date`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 PARTITION BY RANGE (TO_DAYS(flt_date) ) ( PARTITION focus_part_20180101 VALUES LESS THAN (TO_DAYS('20180101')), PARTITION focus_part_20180401 VALUES LESS THAN (TO_DAYS('20180401')), PARTITION focus_part_20180701 VALUES LESS THAN (TO_DAYS('20180701')), PARTITION focus_part_20181001 VALUES LESS THAN (TO_DAYS('20181001')), PARTITION focus_part_20190101 VALUES LESS THAN (TO_DAYS('20190101')), PARTITION focus_part_20190401 VALUES LESS THAN (TO_DAYS('20190401')), PARTITION focus_part_20190701 VALUES LESS THAN (TO_DAYS('20190701')), PARTITION focus_part_20191001 VALUES LESS THAN (TO_DAYS('20191001')), PARTITION focus_part_20190101 VALUES LESS THAN (TO_DAYS('20200101')), PARTITION focus_part_20190401 VALUES LESS THAN (TO_DAYS('20200401')), PARTITION focus_part_20190701 VALUES LESS THAN (TO_DAYS('20200701')), PARTITION focus_part_20191001 VALUES LESS THAN (TO_DAYS('20201001')), PARTITION focus_part_20190101 VALUES LESS THAN (TO_DAYS('20210101')), PARTITION focus_part_20190401 VALUES LESS THAN (TO_DAYS('20210401')), PARTITION focus_part_20190701 VALUES LESS THAN (TO_DAYS('20210701')), PARTITION focus_part_20191001 VALUES LESS THAN (TO_DAYS('20211001')), PARTITION focus_part_20190101 VALUES LESS THAN (TO_DAYS('20220101')), PARTITION focus_part_20190401 VALUES LESS THAN (TO_DAYS('20220401')), PARTITION focus_part_20190701 VALUES LESS THAN (TO_DAYS('20220701')), PARTITION focus_part_20191001 VALUES LESS THAN (TO_DAYS('20221001')), PARTITION focus_part_20190101 VALUES LESS THAN (TO_DAYS('20230101')), PARTITION focus_part_20190401 VALUES LESS THAN (TO_DAYS('20230401')), PARTITION focus_part_20190701 VALUES LESS THAN (TO_DAYS('20230701')), PARTITION focus_part_20191001 VALUES LESS THAN (TO_DAYS('20231001')), PARTITION focus_part_20190101 VALUES LESS THAN (TO_DAYS('20240101')), PARTITION focus_part_20190401 VALUES LESS THAN (TO_DAYS('20240401')), PARTITION focus_part_20190701 VALUES LESS THAN (TO_DAYS('20240701')), PARTITION focus_part_20191001 VALUES LESS THAN (TO_DAYS('20241001')), PARTITION focus_part_20190101 VALUES LESS THAN (TO_DAYS('20250101')), PARTITION focus_part_20190401 VALUES LESS THAN (TO_DAYS('20250401')), PARTITION focus_part_20190701 VALUES LESS THAN (TO_DAYS('20250701')), PARTITION focus_part_20191001 VALUES LESS THAN (TO_DAYS('20251001')), PARTITION focus_part_20190101 VALUES LESS THAN (TO_DAYS('20260101')), PARTITION focus_part_20190401 VALUES LESS THAN (TO_DAYS('20260401')), PARTITION focus_part_20190701 VALUES LESS THAN (TO_DAYS('20260701')), PARTITION focus_part_20191001 VALUES LESS THAN (TO_DAYS('20261001')), PARTITION focus_part_20190101 VALUES LESS THAN (TO_DAYS('20270101')), PARTITION focus_part_20190401 VALUES LESS THAN (TO_DAYS('20270401')), PARTITION focus_part_20190701 VALUES LESS THAN (TO_DAYS('20270701')), PARTITION focus_part_20191001 VALUES LESS THAN (TO_DAYS('20271001')), PARTITION focus_part_20190101 VALUES LESS THAN (TO_DAYS('20280101')), PARTITION focus_part_20190401 VALUES LESS THAN (TO_DAYS('20280401')), PARTITION focus_part_20190701 VALUES LESS THAN (TO_DAYS('20280701')), PARTITION focus_part_20191001 VALUES LESS THAN (TO_DAYS('20281001')), PARTITION focus_part_20190101 VALUES LESS THAN (TO_DAYS('20290101')), PARTITION focus_part_20190401 VALUES LESS THAN (TO_DAYS('20290401')), PARTITION focus_part_20190701 VALUES LESS THAN (TO_DAYS('20290701')), PARTITION focus_part_20191001 VALUES LESS THAN (TO_DAYS('20291001'))); 查看分区表12345678910SELECT partition_name part, partition_expression expr, partition_description descr, table_rows FROM INFORMATION_SCHEMA.partitions WHERE TABLE_SCHEMA = schema() AND TABLE_NAME='focus_p'; 添加测试数据（focus）使用存储过程插入非空字段的数据，插入1600W条数据。123456789101112131415161718delimiter //SET autocommit=0;CREATE PROCEDURE load_part_tab() BEGIN DECLARE v int DEFAULT 0; WHILE v &lt; 16000000 DO INSERT INTO csmbp_flight_focus(id,flt_date) VALUES (v,adddate('2013-01-01 00:00:00',(rand(v)*36520) mod 3652)); SET v = v + 1; END WHILE; COMMIT; END //delimiter ;CALL load_part_tab(); 旧表数据转移至新的分区表1INSERT INTO focus_p SELECT * FROM focus; 总耗时12分6秒。 再次查看分区的存储记录情况： 验证查询对比 查focus表：耗时2分54秒12SELECT * FROM focus f WHERE f.flt_date &gt;= '2017-12-16 00:00:00' AND f.flt_date &lt;= '2018-11-08 00:00:00'; 查focus_p表：耗时28秒12SELECT * FROM focus_p f WHERE f.flt_date &gt;= '2017-12-16 00:00:00' AND f.flt_date &lt;= '2018-11-08 00:00:00'; 分区管理 删除分区：ALTER TABLE focus_p DROP PARTITION p1; 分区合并：ALTER TABLE focus_p REORGANIZE PARTITION p1,p2 INTO (PARTITION p1 VALUES LESS THAN (TO_DAYS(‘20180401’))); 新增分区：ALTER TABLE focus_p ADD PARTITION (PARTITION p_12 VALUES LESS THAN (TO_DAYS(‘20180401’))); 新增分区注意：因原先最后一个分区是PARTITION p_11 VALUES LESS THAN MAXVALUE; 那么应该先合并一个分区再删除被合并的分区，然后在执行新增分区语句，分区名就用被合并的那个分区名； 修改表名先修改旧表名，再把旧表名修改成新表名。12ALTER TABLE focus RENAME focus_old;ALTER TABLE focus_p RENAME focus; 存在的风险 数据完整性的保障和耗时，存在一定的不可控。在把数据转移至新分区表时，服务一直在使用，就会出现在转移数据到完成数据转移的时间间隔中，出现新增数据在旧表上，而新表没有的情况。可以考虑在新表插入完旧表的数据后，做一个count（*）操作，先记录新表刚开始有多少数据量，再新表投入使用后，再count一下旧表的数据，count旧表减去count新表，代表之间的差值，用mysql提供的limit语法，把剩余的差值转移至分区表中。select * from table limit m,n。m表示指定从第几条数据开始取，n表示取多少条数据。因m的数值是从0开始的，所以m=count（*）即可，不用减1。从旧表中指定位置开始导入，n可以取旧表与新表之间的差值。整个数据转移的过程中，测试实验出的时间是总耗时12分6秒，生产环境还是会存在不确定性。 在新表表名替换过程中，服务不中断的情况下，有可能出现，已有事务正在向旧表提交请求。可以考虑不更改表名的操作，而在工程项目中的代码中，更改实体类所映射的表名。 新分区表是否需要加上旧表中的索引。 旧表数据是否需要删除。不建议删除，旧表数据的带有7个索引，DROP操作会产生较长的耗时，具体未验证过。可以考虑把它作为一个备份数据存在。 开启mysql定时任务检查event事件是否开启：SHOW VARIABLES LIKE ‘event_scheduler’; OFF则需要开启：SET GLOBAL event_scheduler = ON; 创建定时创建分区SQL1234567891011121314151617181920212223242526272829303132333435363738394041424344-- 设置该事件使用或所属的数据库USe test;# 如果原来存在该名字的任务计划则先删除DROP EVENT IF EXISTS create_part;# 设置分隔符为 '//' DELIMITER //# 创建计划任务，设置第一次执行时间为'2019-01-01 00:00:00'，并且每年执行一次CREATE EVENT create_part ON SCHEDULE EVERY 1 YEAR STARTS TIMESTAMP '2019-01-01 00:00:00'DO# 开始该计划任务（每一年自动生成下一年的分区，按一个季度分一个区）BEGIN DECLARE v INT DEFAULT 0; WHILE v &lt; 4 DO -- 分区的日期限制 SET @p_date = (SELECT DATE_ADD(curdate() - DAY(curdate()) + 1,INTERVAL (12 + 3*v) MONTH)); -- 分区的名 SET @p_name = (SELECT concat('focus_part_',date_format(@p_date,'%Y%m%d'))FROM DUAL); -- 添加分区sql语句 SET @p_sql = concat('ALTER TABLE focus_p ADD PARTITION(PARTITION ',@p_name,' VALUES LESS THAN (TO_DAYS(\'',@p_date,'\')))'); -- 预处理sql，其中stmt是一个变量 PREPARE stmt FROM @p_sql; -- 执行SQL语句 EXECUTE stmt; -- 释放掉预处理段 DEALLOCATE PREPARE stmt; SET v = v + 1; END WHILE; COMMIT;-- 结束计划任务END// # 将语句分割符设置回 ';'DELIMITER ;#查询事件SELECT * FROM mysql.event;#停止事件ALTER EVENT create_part DISABLE;#开启事件ALTER EVENT create_part ENABLE; 资源使用情况 空闲时： 执行数据转移时：CPU使用率在30%-70%之间，内存占用率40%左右]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019年月度目标与进展]]></title>
    <url>%2F2019%2F01%2F02%2Fannual-summary-2019%2F</url>
    <content type="text"><![CDATA[1月目标 阅读《大败局》第一册、第二册 阅读《从0到1：开启商业与未来的秘密》 阅读教材《马克思主义基本原理概论》 刷题《计算机网络管理》 提炼《通信概论》重点知识并记忆 提炼《马克思主义基本原理概论》重点知识并记忆 已完成 阅读《大败局》第一册、第二册 阅读《从0到1：开启商业与未来的秘密》 阅读教材《马克思主义基本原理概论》 提炼《通信概论》重点知识并记忆 提炼《马克思主义基本原理概论》重点知识并记忆 2月目标 阅读《具体生活》 刷题《计算机网络管理》并背诵重点 刷题《通信概论》并背诵重点 刷题《马克思主义基本原理概论》并背诵重点 阅读《激荡十年，水大鱼大》 已完成 阅读《具体生活》 阅读《激荡十年，水大鱼大》 3月目标 巩固《计算机网络管理》并记忆重点 巩固《通信概论》并记忆重点 巩固《马克思主义基本原理概论》并记忆重点 已完成 巩固《通信概论》并记忆重点 巩固《马克思主义基本原理概论》并记忆重点 4月目标 参加4月自学考试 阅读《浩荡两千年：中国企业公元前7世纪—1869年》 阅读《万万没想到：用理工科思维理解世界》 已完成 参加4月自学考试 阅读《浩荡两千年：中国企业公元前7世纪—1869年》 阅读《万万没想到：用理工科思维理解世界》 5月目标 阅读《跌荡一百年：中国企业1870-1977》 阅读《历代经济变革得失》 复习《新概念英语一》 复习《计算机网络管理》 撰写毕业论文 11月《系统集成项目管理工程师》软考通过 已完成 阅读《跌荡一百年：中国企业1870-1977》 阅读《历代经济变革得失》 复习《新概念英语一》 4月自学考试成绩已通过 6月目标 复习《计算机网络管理》 阅读教材《系统集成项目管理工程师》 自学教材《高等数学-工本》 自学《新概念英语二》 毕业论文开题报告 阅读《吴敬琏传》 阅读《全球科技通史》 已完成 复习《计算机网络管理》 毕业论文开题报告 阅读《吴敬琏传》 阅读《全球科技通史》 7月目标 刷题《计算机网络管理》 阅读教材《系统集成项目管理工程师》 自学教材《高等数学-工本》 自学《新概念英语二》 撰写毕业论文 阅读《精进2：解锁万物的心智进化法》 已完成 阅读教材《系统集成项目管理工程师》 阅读《精进2：解锁万物的心智进化法》 完成一篇博客文章的输出 8月目标 刷题《计算机网络管理》 自学教材《高等数学-工专》 自学教材《高等数学-工本》 阅读《把生命浪费在美好的事物上》 毕业论文初稿编写 已完成 阅读《把生命浪费在美好的事物上》 毕业论文初稿编写 未完成 刷题《计算机网络管理》 自学教材《高等数学-工专》 自学教材《高等数学-工本》 9月目标 刷题《计算机网络管理》 自学教材《高等数学-工专》 自学教材《高等数学-工本》 毕业论文终稿 已完成 刷题《计算机网络管理》 毕业论文终稿 未完成 自学教材《高等数学-工专》 自学教材《高等数学-工本》 10月目标 参加10月自学考试 《白帽子讲Web安全》 复习《系统集成项目管理工程师》 自学教材《高等数学-工专》 已完成 参加10月自学考试 《白帽子讲Web安全》 复习《系统集成项目管理工程师》 未完成 自学教材《高等数学-工专》 11月目标 参加11月软考《系统集成项目管理工程师》 参加11月计算机类自学考试实践考核 自学教材《高等数学-工专》 阅读《格局》 阅读《阿里巴巴Java开发手册》 再读《深入理解Java虚拟机》 已完成 参加11月软考《系统集成项目管理工程师》 参加11月计算机类自学考试实践考核 阅读《格局》 未完成 自学教材《高等数学-工专》，已学到定积分 阅读《阿里巴巴Java开发手册》 再读《深入理解Java虚拟机》 12月目标 自学教材《高等数学-工专》 阅读《阿里巴巴Java开发手册》 复习《计算机网络管理》 阅读《我曾走在崩溃的边缘》 已完成 阅读《阿里巴巴Java开发手册》 复习《计算机网络管理》 阅读《我曾走在崩溃的边缘》 未完成 自学教材《高等数学-工专》，已学到概率论初步]]></content>
      <categories>
        <category>随想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[回望2018]]></title>
    <url>%2F2018%2F12%2F29%2Flook-back-2018%2F</url>
    <content type="text"><![CDATA[回忆多似伤感2018即将消逝，经历了很多，成长了很多。但是这些成长却是用痛苦跟折磨堆积起来的。我不知道什么是幸福，因为我一直在追赶。5月份以前，每天也就按部就班的推进学习计划。到了6月开始，因为家庭的一些事情，整个心情、心态都一直处于紧绷状态。我觉得自己是一个凡人，甚至一个庸人。这些事情的处理、应对，让我深深感受到，无知才是我这种家庭最大的敌人。我一直在想，知识到底是什么？近半年的时间，完全没有上半年那样能够踏实的静下心来看会书。朋友说是压力。其实想想，也是。压力一直都有，之前只是某一单方面的压力，能够很好的转化为学习的动力。而5月之后，压力的陡增，导致心态一直都处于扭曲的状态。但是至少有一件事情，没有落下。那就是每天的学习。我并不认为自己很厉害，也并不认为自己很自律。对于学习，我只是不敢再放弃。在求学的道路上，十二年的赛跑中，最后三年的自暴自弃，一直到现在都在影响着我的人生。 展望未来未来到底是什么？我到现在还清晰的记得，以前小学五年级时，一个人放学回家，走在路上，傻傻的在想，我往左走两下，往右走两下，会不会影响明天发生在我身上的一些未知事情或别人身上的事情呢？小时候铁臂阿童木、哆啦A梦看多了。到现在，特别的笃定因果关系。撞的南墙太多了，所以特别的笃定。对于未来，也没有特别的设想。能够按照心里既定的计划路线去走好接下来的两年，已是最大的幸福。所以，为了幸福。加油啊，小伙子。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018年月度目标与进展]]></title>
    <url>%2F2018%2F10%2F15%2Fannual-summary-2018%2F</url>
    <content type="text"><![CDATA[1月目标 完成自考4月报考 阅读《大学之路》第一册 阅读《文明之光》第二册 阅读教材《数据结构》 已完成 完成一篇博客文章的输出 完成自考4月报考 阅读《大学之路》第一册 阅读《文明之光》第二册 阅读教材《数据结构》 2月目标 刷题《数据结构》，提炼重点知识 阅读教材《网络工程》 阅读教材《计算机网络安全》 记忆理解《计算机网络原理》重点知识 阅读《大学之路》第二册 阅读《文明之光》第三册 已完成 完成一篇博客文章的输出 刷题《数据结构》，提炼重点知识 阅读教材《网络工程》 阅读教材《计算机网络安全》 记忆理解《计算机网络原理》重点知识 阅读《大学之路》第二册 阅读《文明之光》第三册 3月目标 刷题《计算机网络安全》，提炼重点知识 刷题《网络工程》，提炼重点知识 记忆理解《计算机网络原理》重点知识 记忆理解《数据结构》重点知识 阅读《数学之美》 阅读《文明之光》第四册 阅读《见识》 阅读《智能时代》 泛读《大话数据结构》 已完成 完成一篇博客文章的输出 刷题《计算机网络安全》，提炼重点知识 刷题《网络工程》，提炼重点知识 记忆理解《计算机网络原理》重点知识 记忆理解《数据结构》重点知识 阅读《数学之美》 阅读《文明之光》第四册 阅读《见识》 阅读《智能时代》 泛读《大话数据结构》 4月目标 刷题《计算机网络安全》，提炼重点知识 记忆理解《计算机网络安全》重点知识 参加4月自学考试 再次阅读《深入理解Java虚拟机:JVM高级特性与最佳实践》 已完成 完成一篇博客文章的输出 刷题《计算机网络安全》，提炼重点知识 记忆理解《计算机网络安全》重点知识 参加4月自学考试 再次阅读《深入理解Java虚拟机:JVM高级特性与最佳实践》 5月目标 阅读《计算机组成原理》 阅读《智识分子：做个复杂的现代人》 阅读《高手：精英的见识和我们的时代》 阅读《如何有效阅读一本书》 阅读《学会学习：从认知自我到高效学习》 阅读《抗压力：逆境重生法则》 已完成 完成一篇博客文章的输出 阅读《计算机组成原理》 阅读《智识分子：做个复杂的现代人》 阅读《高手：精英的见识和我们的时代》 阅读《如何有效阅读一本书》 阅读《学会学习：从认知自我到高效学习》 阅读《抗压力：逆境重生法则》 6月目标 阅读教材《数据库系统原理》 阅读教材《互联网及其应用》 已完成 阅读教材《数据库系统原理》 阅读教材《互联网及其应用》 完成一篇博客文章的输出 《新概念英语一》进展的很缓慢，到目前为止推进到第55课。 7月目标 阅读教材《网络操作系统》 提炼《数据库系统原理》重点知识 阅读《踏踏实实学英语》 阅读《记忆的窍门》 阅读《学习贵在开窍》 报考10月考试《网络操作系统》《数据库系统原理》《计算机网络管理》《互联网及其应用》 已完成 阅读教材《网络操作系统》 提炼《数据库系统原理》重点知识 阅读《踏踏实实学英语》 阅读《记忆的窍门》 阅读《学习贵在开窍》 8月目标 提炼《网络操作系统》重点知识 刷题《数据库系统原理》 阅读教材《计算机网络管理》 阅读《硅谷钢铁侠》 阅读《天涯若比邻》 阅读《整理的艺术》 阅读《零秒思考》 已完成 提炼《网络操作系统》重点知识 刷题《数据库系统原理》 阅读《硅谷钢铁侠》 阅读《天涯若比邻》 阅读《整理的艺术》 阅读《零秒思考》 9月目标 刷题《网络操作系统》，记忆理解重点知识点 刷题《数据库系统原理》，记忆理解重点知识点 阅读《雷军:世界需要我的突围》 阅读《麦肯锡教我的思考武器》 阅读《麦肯锡入职培训第一课》 已完成 刷题《网络操作系统》，记忆理解重点知识点 刷题《数据库系统原理》，记忆理解重点知识点 阅读《雷军:世界需要我的突围》 阅读《麦肯锡教我的思考武器》 阅读《麦肯锡入职培训第一课》 10月目标 记忆理解《网络操作系统》重点知识点 记忆理解《数据库系统原理》重点知识点 记忆理解《互联网及其应用》重点知识点 阅读《人类简史》 参加10月自学考试 已完成 记忆理解《网络操作系统》重点知识点 记忆理解《数据库系统原理》重点知识点 记忆理解《互联网及其应用》重点知识点 阅读《人类简史》 参加10月自学考试 11月目标 阅读教材《计算机网络管理》 阅读《高性能网站建设指南》 阅读教材《通信概论》 阅读《态度》 阅读《番茄工作法图解》 已完成 10月考试《网络操作系统》、《数据库系统原理》、《互联网及其应用》顺利通过 阅读教材《计算机网络管理》 阅读《态度》 阅读《腾讯传》 这个月过的比较迷糊，自我感觉有点变懒了。精神状态不佳。 12月目标 阅读教材《通信概论》 阅读《高性能网站建设指南》 阅读《番茄工作法图解》 刷题《计算机网络管理》，记忆理解重点知识点 已完成 阅读教材《通信概论》 阅读《番茄工作法图解》]]></content>
      <categories>
        <category>随想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络原理学习部分的总结]]></title>
    <url>%2F2018%2F07%2F30%2Fnetwork%2F</url>
    <content type="text"><![CDATA[前沿从去年9月开始，看教材《计算机网络原理》到4月考试通过，前前后后花了大半年时间。必须得承认，我不是神童，也不是学霸，不是那种一学就会的体质。《计算机网络原理》绝对是我啃得最慢，也是我认为最枯燥的一本教科书。但是我还是靠自学把它啃下来了，磨炼了心性。对于计算机网络世界的理解，真的上升了不少，不仅仅只是编程。曾国藩对于学习，提出过四点要求，个人觉得非常有意思。一曰看生书宜求速，不多读则太陋。一曰温旧书宜求熟，不背诵则易忘。一曰习字宜有恒，不善写则如身之无衣，山之无木。一曰作文宜苦思，不善作则如人之哑不能言，马之肢不能行。 计算机网络概述在教科书中，有一段话是需要背的。什么是计算机网络？只有当你能够很顺的背下来，你才会去回味、去理解概述的含义。这里再借鉴一下教科书上的内容。计算机网络，是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。在整个计算机网络发展史中，早期60年代的计算机网络是美国军方研制的ARPNET网，主要是科研机构为实现资源共享。到了80年代诞生出统一的标准-OSI参考模型。也就是常说的七层模型。教科书都是以七层模型来讲，但是事实上的标准是TCP/IP四层模型。七层模型从高往低依次是：应、表、会、传、网、数、物（记第一个字，刚好是一句七言绝句诗，方便记忆）。四层模型从高往低依次：应、传、互、主。每一层中所包含的协议：（两张图都是网上找的，跟教科书上也是一样的，隔个三五天翻看一下，一回生二回熟，慢慢就记住了）发送端在将数据进行发送时，需要经过一系列的封装。接收端在接收数据的时候，再进行相应的解封。 物理层总结的方式也按教科书章节的划分，从底层往上层温习。物理层主要是实现比特流的透明传输，为数据链路层提供数据传输服务，直接面向实际承担数据传输的物理介质。其实就是最原始的二进制位数据的传输。传输介质主要是有线、无线两大类。有线传输介质中有双绞线、同轴电缆、光钎。双绞线跟同轴电缆不可避免的就需要把二进制数据，转换成电频进行传输。专业术语叫调制解调器，俗称猫（MODEL）。在接收方中，再把电信号还原成二进制数据。而光纤传输的是光信号，需要发送端将其转成光信号，接收端再还原成电信号。数据在传输过程中无可避免的就会出现传输速率，信道容量，误码率，通信方式的问题。就类似现实社会中，公司有一堆的货物要运到某个地方，货物就是数据，运输的路径其实就是传输过程，是走汽车运输还是火车运输，货物所运达的时间，传输的速率是不同的。在传输过程中可能会出现少了某一个物品。货物很多，是一次一次的运输，还是一次找10个承运人来运输…等等这些问题。这里不得不提一位伟人-香农。香农提出了信息熵的概念，为信息论和数字通信奠定了基础。物理层的主要任务确定传输媒体接口的一些特性。主要是机械特性、电气特性、功能特性、规程特性。 机械特性：例如网卡接口的数目、形状、大小等。 电气特性：电压的范围-5V到+5V。 功能特性：用电压的取值范围来表示比特数据。-5V到0V表示0，+5V到0V表示1. 规程特性：规定建立连接时各个相关部件的工作步骤。信号的编码方式曼彻斯特编码：bit中间有信号跳变，从低到高的跳变表示0，从高到低的跳变表示1。差分曼彻斯特编码：bit中间有信号跳变，bit与bit之间也有信号跳变表示下一bit为0。bit与bit之间无信号跳变，表示下一bit为1。数据链路层数据链路层主要是对物理层传输原始bit流功能的加强，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。数据链路层的传送单位称为帧。数据链路层主要是要解决三个问题： 封装成帧：就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧，确定帧的界限。首部和尾部的一个重要作用就是进行帧定界。 透明传输：是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使接收方不会将这样的数据误认为是某种控制信息。 差错控制：传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。在数据链路层传送的帧中，广泛使用了循环冗余检验CRC的检错技术。网络层网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括路由选择、拥塞控制、网际互连等。 RIP协议：路由信息协议，简单的距离向量路由协议。每个RIP路由器都保存了一张路由表，每一项对应着一个目的地。其中每项包括了目的地的IP地址、到目的地的路径距离的度量1、到目的地的路径的下一个路由表的IP地址、路由改变标志以及和这条路由有关的一些计时器。其采用的距离度量是一种非常简单的到目的地距离的测量方式：站点计数度量，也就是该路由要经过的路由器个数。 OSPF协议：链路状态路由协议，每个路由器通过维护它自己的本地链路状态信息，即路由器到子网的链路状态和可以到达的邻居路由器，通过扩散的方法把更新了的本地链路状态信息广播给自治系统中的每个路由器。这样每个路由器都知道自治系统内部的拓扑结构和链路状态信息。路由器根据这个链路状态库计算出到每个目的地的最短路径。所有路由器都采用相同的算法来计算最短路由，而且这个计算是在路由器本地进行的。动态的路由算法，能够自动而快速地适应拓扑结构的变化。 IP协议：互连网协议，将多个网络连成一个互连网，把高层的数据以多个数据报的形式通过互连网分发出去。 ARP协议：地址转换协议。在TCP/IP网络环境下，每个主机都分配了一个32位的IP地址，这种互联网地址是在网际范围标识主机的一种逻辑地址。为了让报文在物理网上传送，必须知道彼此的物理地址。以以太网环境为例，为了正确地向目的站传送报文，必须把目的站32位IP地址转换成48位以太网目的地址，此时所需要的协议就是ARP协议。 RARP协议：反向地址转换协议，使用与一种特殊的情况，如果站点初始化以后，只有自己的物理网络地址而没有IP地址，则可以通过RARP协议发出广播请求，征求自己的IP地址。而RARP服务器负责回答。无IP地址的站点可以通过RARP协议取得自己的IP地址。 ICMP协议：互联网控制报文协议。 IGMP协议：因特网组管理协议。传输层 TCP协议：需要将传输的数据进行分段传输，建立会话，可靠传输，流量控制。传输层协议和应用层协议之间的关系：端口号加使用的传输层协议，用以标识应用程序。可靠传输原理：ARQ自动请求重传，采用确认和重传机制。TCP报文格式：TCP建立连接三次握手的过程：TCP释放连接四次挥手的过程： UDP协议：一个数据包就能够完成数据通信，不分段，不需要建立会话，不需要流量控制，不可靠传输。]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本的回顾]]></title>
    <url>%2F2018%2F05%2F12%2Fshell%2F</url>
    <content type="text"><![CDATA[对新的编程语言学习的一些感想最近重新温习了一下Shell，系统的学习了一遍。发现其实以前对Shell的理解与认知仅仅只是停留在马上用的层面。仔细想了想，任何一种编程语言或者是其他新知识的学习，个人觉得应该离不开几个要素。这样才能在自己学习中，建立对新知识一个系统的认知。 了解Shell的基本历史，可以很快速的浏览一遍，有个大概轮廓或印象。 Shell编程中的变量、流程、语法、函数（重点） 掌握知识，并运用自如-&gt;大量的练习 重点其实是在第二点，掌握一门编程语言最基本的四个点，其实基本能上手了。至于熟练程度，那都是靠不停的使用堆砌起来的。掌握了系统的学习过程，遇到问题-&gt;解决问题，才能知其然。 shell历史Shell目前是一种统称，UNIX系统上有多种Shell。目前各种Linux发行版标配的Shell都是bash。Shell脚本不需要编译，属于解释执行的，一行一行读取并执行这些命令。类似的解释执行的还有JS脚本、HTML等，都是一行一行顺序执行的。已进入Linux的黑窗，敲一行命令，就刚好能执行。其实就是因为系统在启动的时候，就已经运行了一个shell解释器，等着用户的输入再来解释执行。 执行脚本1234#! /bin/sh#这是注释cd ..ls #表示注释，#!表示该脚本指定的某解释器进行解释执行编写好以后，得运行一遍吧。在Linux操作系统中，启动shell脚本有4种方式。1234source ./test.sh. ./test.shsh test.sh./test.sh 以上4种方式的区别在于，source跟.是属于shell的内建命令，也就是说用这两种方式启动，是不会产生新进程的。用sh命令，则会产生在当前进程上产生一个子进程来运行该脚本。提示：权限不够。表示该新建的文件没有执行权，需要执行chmod +x test.sh，为test.sh添加执行权。 基本语法Shell中的变量主要有两种。 变量环境变量：以从父进程传给子进程。env命令可以直接打印查看当前系统的环境变量。本地变量：只存在于当前Shell进程，格式是：VARNAME=value（等号之间没有空格）。可使用export命令可以把本地变量导出为环境变量。export VARNAME=value 命令代换用一个自定义的变量名承载系统命令。例如：DATE=`date`，echo $DATE则可以实现直接敲命令date的效果。 转义字符有些特殊意义的字符，如果只想取它字面值，可以\进行转义，用于去除紧跟其后的单个字符的特殊意义。 单引号字符串的界定符，单引号中的内容会原样输出。echo ‘$SHELL’则会输出$SHELL 双引号字符串的界定符，被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。echo “$PATH”则会输出环境变量PATH的值。作为一种好的Shell编程习惯，应该总是把变量的取值放在双引号之中。 流程命令test或 [] 可以测试一个条件是否成立，0表示成功，1表示失败。可以用特殊变量$?读出。 分支if/then/elif/else/fi在Shell中用if、then、elif、else、fi这几条命令实现分支控制。123if [ -f ~/.bashrc ]; then . ~/.bashrcfi 1234567891011#! /bin/shecho &quot;Is it morning? Please answer yes or no.&quot;read YES_OR_NOif [ &quot;$YES_OR_NO&quot; = &quot;yes&quot; ]; then echo &quot;Good morning!&quot;elif [ &quot;$YES_OR_NO&quot; = &quot;no&quot; ]; then echo &quot;Good afternoon!&quot;else echo &quot;Sorry, $YES_OR_NO not recognized. Enter yes or no.&quot;fi read命令的作用是等待用户输入一行字符串，将该字符串存到一个Shell变量中。 case/esacShell脚本的case可以匹配字符串和Wildcard，每个匹配分支可以有若干条命令，末尾必须以;;结束，执行时找到第一个匹配的分支并执行相应的命令，然后直接跳到esac之后。123456789101112#! /bin/shecho "Is it morning? Please answer yes or no."read YES_OR_NOcase "$YES_OR_NO" inyes|y|Yes|YES) echo "Good Morning!";;[nN]*) echo "Good Afternoon!";;*) echo "Sorry, $YES_OR_NO not recognized. Enter yes or no.";;esac 循环for/do/doneShell脚本的for循环结构，类似于某些编程语言的foreach循环。也就是遍历。12345#! /bin/shfor FRUIT in apple banana pear; do echo "I like $FRUIT"done while/do/done12345678#! /bin/shecho "Enter password:"read TRYwhile [ "$TRY" != "secret" ]; do echo "Sorry, try again" read TRYdone 函数Shell中的函数，在其定义中是没有返回值也没有参数列表。123456#! /bin/shfoo()&#123; echo "Function foo is called";&#125;echo "-=start=-"fooecho "-=end=-" 位置参数和特殊变量1234567$0 相当于C语言main函数的argv[0]$1、$2... 这些称为位置参数（Positional Parameter），相当于C语言main函数的argv[1]、argv[2]...$# 相当于C语言main函数的argc - 1，注意这里的#后面不表示注释$@ 表示参数列表"$1" "$2" ...，例如可以用在for循环中的in后面。$* 表示参数列表"$1" "$2" ...，同上$? 上一条命令的Exit Status$$ 当前进程号 Shell脚本调试方法123-n 读一遍脚本中的命令但不执行，用于检查脚本中的语法错误。-v 一边执行脚本，一边将执行过的脚本命令打印到标准错误输出。-x 提供跟踪执行信息，将执行的每一条命令和结果依次打印出来。 $ sh -x ./test.sh 正则表达式正则表达式分为Basic正则和Extended正则，也就是基本正则和扩展正则。Linux操作系统中，grep命令，默认使用的是基本正则。egrep命令使用的是扩展正则。 基本语法-字符类1234. 匹配任意一个字符 abc.可以匹配abcd、abc9等[] 匹配括号中的任意一个字符 [abc]可以匹配ad、bd、cd- 在[]括号内表示字符范围 [0-9a-fA-F]可以匹配一位十六进制数字^ 位于[]括号的开头，匹配除括号内字符之外的任意一个字符 [^xy]可以匹配a1、b1，不匹配x1、y1 基本语法-数量限定符1234567? 紧跟它前面的单元，匹配零次或一次 [0-9]?\.[0-9]匹配0.0、2.3、.5等，.号是特殊字符，用\转义一下。+ 紧跟它前面的单元，匹配一次或多次 [a-zA-z0-9_.-]+@[a-zA-z0-9_.-]+\.[a-zA-z0-9_.-]匹配email地址* 紧跟它前面的单元，匹配零次或多次 [0-9][0-9]*匹配至少一位数字&#123;N&#125; 大括号，精确匹配N次 [0-9][0-9]&#123;2&#125;匹配从100到999的整数&#123;N,&#125; 匹配至少N次 [0-9][0-9]&#123;2,&#125;匹配三位以上的整数&#123;,M&#125; 匹配最多M次 [0-9]&#123;,1&#125;相当于[0-9]?&#123;N,M&#125; 至少N次，最多M次 ^[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;$匹配IP地址 基本语法-位置限定符12^ 匹配行首的位置$ 匹配行末的位置 基本语法-其他特殊定符123\ 转义字符，普通字符转义为特殊字符，特殊字符转义为普通字符() 将正则表达式的一部分括起来组成一个单元，可以对整个单元使用数量限定符 ([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1-3&#125;匹配IP地址| 连接两个子表达式，表示或的关系 n(o|either)匹配no或neither]]></content>
      <categories>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构之树形结构]]></title>
    <url>%2F2018%2F04%2F26%2Fdata_struct_tree%2F</url>
    <content type="text"><![CDATA[《回顾数据结构的基础知识》 非线性结构-树树形结构属于非线性结构，树中结点之间具有明确的层次关系，并且结点之间有分支。例如权限、行政组织、家谱等。树形结构最大的特点是：它是一个递归结构。度、深度、层数、左孩子、右孩子、森林之类的名词，这里不就再解释了。 二叉树二叉树不仅仅只是在树形结构中非常重要，在实际问题解决过程中，往往也是转换为二叉树的形式解决的。例如像Java中的HashMap，抽象出来的数据结构是红黑树。TreeMap，抽象出来的数据结构是二叉排序树。关于定义，这里就不多说了。其最大的特点就是每个结点最多只有两棵子树。二叉树的存储方式，分为顺序存储结构跟链式存储结构。顺序存储结构比较浪费空间，基本都是采用链式存储。顺序存储结构是把二叉树补充成一个完全二叉树，添加一些实际上不存在的虚节点，从根节点开始，一层一层从左往右依次存放到顺序表中。二叉树的遍历主要有三种。先序遍历、中序遍历、后序遍历。所谓的先、中、后，都是相对于对应树或子树的根节点而言的。先序遍历：其规律是根、左、右。中序遍历：其规律是左、根、右。后序遍历：其规律是左、右、根。 C代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;typedef struct TreeNode&#123; //数据域 char data; //左孩子 struct TreeNode * pLeftChild; //右孩子 struct TreeNode * pRightChild;&#125;TREENODE, *PTREENODE;//创建一个树PTREENODE createTree();//先序输出void printXianXu(PTREENODE);//中序输出void printZhongXu(PTREENODE);//后序输出void printHouXu(PTREENODE);//计算深度int binTreeDepth(PTREENODE);//得到所有的节点数int sumNodes(PTREENODE rootNode);//得到所有的叶子节点数int sumLeafNodes(PTREENODE rootNode);//copy一个树PTREENODE copyTree(PTREENODE);//使用#号创建法，创建一个树PTREENODE createTree1();void main()&#123; int depth, sum, sumLeaf; PTREENODE tree; PTREENODE rootNode = createTree(); printXianXu(rootNode); //printZhongXu(rootNode); //printHouXu(rootNode); depth = binTreeDepth(rootNode); printf("树的深度为：%d\n", depth); sum = sumNodes(rootNode); printf("树的节点总数为：%d\n", sum); sumLeaf = sumLeafNodes(rootNode); printf("树的叶子节点总数为：%d\n", sumLeaf); tree = copyTree(rootNode); printXianXu(tree); tree = createTree1(); printXianXu(tree);&#125;//创建树PTREENODE createTree()&#123; PTREENODE pNodeA = (PTREENODE)malloc(sizeof(TREENODE)); PTREENODE pNodeB = (PTREENODE)malloc(sizeof(TREENODE)); PTREENODE pNodeC = (PTREENODE)malloc(sizeof(TREENODE)); PTREENODE pNodeD = (PTREENODE)malloc(sizeof(TREENODE)); PTREENODE pNodeE = (PTREENODE)malloc(sizeof(TREENODE)); pNodeA-&gt;data = 'A'; pNodeB-&gt;data = 'B'; pNodeC-&gt;data = 'C'; pNodeD-&gt;data = 'D'; pNodeE-&gt;data = 'E'; pNodeA-&gt;pLeftChild = pNodeB; pNodeA-&gt;pRightChild = pNodeC; pNodeB-&gt;pLeftChild = pNodeB-&gt;pRightChild = NULL; pNodeC-&gt;pLeftChild = pNodeD; pNodeC-&gt;pRightChild = NULL; pNodeD-&gt;pLeftChild = NULL; pNodeD-&gt;pRightChild = pNodeE; pNodeE-&gt;pLeftChild = pNodeE-&gt;pRightChild = NULL; return pNodeA;&#125;//先序输出void printXianXu(PTREENODE rootNode)&#123; if(NULL != rootNode)&#123; //先序访问根节点 printf("%c\n", rootNode-&gt;data); if(NULL != rootNode-&gt;pLeftChild)&#123; //再先序访问左子树 printXianXu(rootNode-&gt;pLeftChild); &#125; if(NULL != rootNode-&gt;pRightChild)&#123; //再先序访问右子树 printXianXu(rootNode-&gt;pRightChild); &#125; &#125;&#125;//中序输出void printZhongXu(PTREENODE rootNode)&#123; if(NULL != rootNode)&#123; if(NULL != rootNode-&gt;pLeftChild)&#123; //中序访问左子树 printZhongXu(rootNode-&gt;pLeftChild); &#125; //再中序访问根节点 printf("%c\n", rootNode-&gt;data); if(NULL != rootNode-&gt;pRightChild)&#123; //再中序访问右子树 printZhongXu(rootNode-&gt;pRightChild); &#125; &#125;&#125;//后序输出void printHouXu(PTREENODE rootNode)&#123; if(NULL != rootNode)&#123; if(NULL != rootNode-&gt;pLeftChild)&#123; //后序访问左子树 printHouXu(rootNode-&gt;pLeftChild); &#125; if(NULL != rootNode-&gt;pRightChild)&#123; //再后序访问右子树 printHouXu(rootNode-&gt;pRightChild); &#125; //再后序访问根节点 printf("%c\n", rootNode-&gt;data); &#125;&#125;//深度int binTreeDepth(PTREENODE rootNode)&#123; int depL, depR; if(rootNode ==NULL)&#123; return 0; &#125;else&#123; //计算左子树的深度 depL = binTreeDepth(rootNode-&gt;pLeftChild); //计算右子树的深度 depR = binTreeDepth(rootNode-&gt;pRightChild); if(depL &gt; depR)&#123; return depL + 1; &#125;else&#123; return depR + 1; &#125; &#125;&#125;//所有的节点int sumNodes(PTREENODE rootNode)&#123; int sumNodesL, sumNodesR; if(rootNode ==NULL)&#123; return 0; &#125;else&#123; sumNodesL = sumNodes(rootNode-&gt;pLeftChild); sumNodesR = sumNodes(rootNode-&gt;pRightChild); return sumNodesL + sumNodesR + 1; &#125;&#125;//得到所有的叶子节点数int sumLeafNodes(PTREENODE rootNode)&#123; int sumNodesL, sumNodesR; if(rootNode ==NULL)&#123; return 0; &#125; if(rootNode-&gt;pLeftChild == NULL &amp;&amp; rootNode-&gt;pRightChild == NULL)&#123; return 1; &#125;else&#123; sumNodesL = sumLeafNodes(rootNode-&gt;pLeftChild); sumNodesR = sumLeafNodes(rootNode-&gt;pRightChild); return sumNodesL + sumNodesR; &#125;&#125;//copy一个树PTREENODE copyTree(PTREENODE rootNode)&#123; PTREENODE newNode; PTREENODE leftNode; PTREENODE rightNode; if(rootNode == NULL)&#123; return NULL; &#125; //copy左子树 if(rootNode-&gt;pLeftChild != NULL)&#123; leftNode = copyTree(rootNode-&gt;pLeftChild); &#125;else&#123; leftNode = NULL; &#125; //copy右子树 if(rootNode-&gt;pRightChild != NULL)&#123; rightNode = copyTree(rootNode-&gt;pRightChild); &#125;else&#123; rightNode = NULL; &#125; //创建一个新节点 newNode = (PTREENODE)malloc(sizeof(TREENODE)); newNode-&gt;pLeftChild = leftNode; newNode-&gt;pRightChild = rightNode; newNode-&gt;data = rootNode-&gt;data; return newNode;&#125;/**//二叉树的非递归遍历算法void inorder(PTREENODE rootNode)&#123; //辅助指针变量 PTREENODE node; //初始化一个栈 STACK stack; init(&amp;stack); //把根节点压栈 push(&amp;stack, rootNode); //栈不为空，就一直循环。知道栈为空 while(!isEmpty(&amp;stack))&#123; //栈顶的元素不给空，则一直循环 while(getTop(&amp;stack)&#123; //把左子树一直压入栈中 push(&amp;stack, getTop(&amp;stack)-&gt;pLeftChild); &#125; //执行到这里，说明栈顶是一个NULL元素。左子树为空的节点 //把栈顶的空元素，出栈 node = pop(&amp;stack); //栈不为空时，说明还没有结束 if(!isEmpty(&amp;stack))&#123; //左子树没有，访问根节点。栈顶的那个元素则是根节点 printf("%c\n", getTop(&amp;stack)-&gt;data); //访问完根节点，根节点则出栈 node = pop(&amp;stack); //把右子树压入栈中。执行完这一句，则进行下一个循环了。 push(&amp;stack, node-&gt;pRightChild); &#125; &#125;&#125;*///使用#号创建法，创建一个树PTREENODE createTree1()&#123; PTREENODE node = NULL; PTREENODE leftNode = NULL; PTREENODE rightNode = NULL; char ch; scanf("%c", &amp;ch); //#号，则不创建树节点 if(ch == '#')&#123; return NULL; &#125;else&#123; //创建一个节点 node = (PTREENODE)malloc(sizeof(TREENODE)); node-&gt;data = ch; node-&gt;pLeftChild = createTree1(); node-&gt;pRightChild = createTree1(); return node; &#125;&#125; Java代码123456789101112131415161718192021222324252627282930313233package datastructure.part.tree;/** * @description * @author Denghs * @version 1.0,2018年6月30日 上午10:16:49 * @remark 树节点 */public class TreeNode&lt;T&gt; &#123; private TreeNode&lt;T&gt; leftNode;//左子树 private TreeNode&lt;T&gt; rightNode;//右子树 private T data;//数据部分 public TreeNode&lt;T&gt; getLeftNode() &#123; return leftNode; &#125; public void setLeftNode(TreeNode&lt;T&gt; leftNode) &#123; this.leftNode = leftNode; &#125; public TreeNode&lt;T&gt; getRightNode() &#123; return rightNode; &#125; public void setRightNode(TreeNode&lt;T&gt; rightNode) &#123; this.rightNode = rightNode; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199package datastructure.part.tree;/** * @description * @author Denghs * @version 1.0,2018年6月30日 上午10:22:57 * @remark */public class TreeUtils &#123; /** * @param node * @return */ public static TreeNode&lt;String&gt; createTree() &#123; TreeNode&lt;String&gt; nodeA = new TreeNode&lt;String&gt;(); TreeNode&lt;String&gt; nodeB = new TreeNode&lt;String&gt;(); TreeNode&lt;String&gt; nodeC = new TreeNode&lt;String&gt;(); TreeNode&lt;String&gt; nodeD = new TreeNode&lt;String&gt;(); TreeNode&lt;String&gt; nodeE = new TreeNode&lt;String&gt;(); nodeA.setData("A"); nodeB.setData("B"); nodeC.setData("C"); nodeD.setData("D"); nodeE.setData("E"); nodeA.setLeftNode(nodeB); nodeB.setLeftNode(nodeC); nodeA.setRightNode(nodeD); nodeD.setLeftNode(nodeE); return nodeA; &#125; /** * 先序输出 * @param rootNode */ public static &lt;T&gt; void printXianXu(TreeNode&lt;T&gt; rootNode) &#123; if(null != rootNode)&#123; //先输出根节点 System.out.println(rootNode.getData().toString()); //访问左子树 if(null != rootNode.getLeftNode())&#123; printXianXu(rootNode.getLeftNode()); &#125; //访问右子树 if(null != rootNode.getRightNode())&#123; printXianXu(rootNode.getRightNode()); &#125; &#125; &#125; /** * 中序输出 * @param rootNode */ public static &lt;T&gt; void printZhongXu(TreeNode&lt;T&gt; rootNode) &#123; if(null != rootNode)&#123; //访问左子树 if(null != rootNode.getLeftNode())&#123; printZhongXu(rootNode.getLeftNode()); &#125; //输出根节点 System.out.println(rootNode.getData().toString()); //访问右子树 if(null != rootNode.getRightNode())&#123; printZhongXu(rootNode.getRightNode()); &#125; &#125; &#125; /** * 后序输出 * @param rootNode */ public static &lt;T&gt; void printHouXu(TreeNode&lt;T&gt; rootNode) &#123; if(null != rootNode)&#123; //访问左子树 if(null != rootNode.getLeftNode())&#123; printHouXu(rootNode.getLeftNode()); &#125; //访问右子树 if(null != rootNode.getRightNode())&#123; printHouXu(rootNode.getRightNode()); &#125; //输出根节点 System.out.println(rootNode.getData().toString()); &#125; &#125; /** * 树的高度 * @param rootNode * @return */ public static &lt;T&gt; int treeDepth(TreeNode&lt;T&gt; rootNode) &#123; if(null == rootNode)&#123; return 0; &#125; else &#123; //计算左子树的深度 int depL = treeDepth(rootNode.getLeftNode()); //计算右子树的深度 int depR = treeDepth(rootNode.getRightNode()); if(depL &gt; depR)&#123; return depL + 1; &#125;else&#123; return depR + 1; &#125; &#125; &#125; /** * 计算所有节点数 * @param rootNode * @return */ public static &lt;T&gt; int sumNodes(TreeNode&lt;T&gt; rootNode) &#123; if(null == rootNode)&#123; return 0; &#125; //计算左子树的节点 int sumL = sumNodes(rootNode.getLeftNode()); //计算右子树的节点 int sumR = sumNodes(rootNode.getRightNode()); return sumL + sumR + 1; &#125; /** * 计算所有的叶子节点 * @param rootNode * @return */ public static &lt;T&gt; int sumLeafNodes(TreeNode&lt;T&gt; rootNode) &#123; if(null == rootNode)&#123; return 0; &#125; //没有左子树和右子树的节点，就是叶子节点 if(null == rootNode.getLeftNode() &amp;&amp; null == rootNode.getRightNode())&#123; return 1; &#125; else &#123; int sumNodesL = sumLeafNodes(rootNode.getLeftNode()); int sumNodesR = sumLeafNodes(rootNode.getRightNode()); return sumNodesL + sumNodesR; &#125; &#125; /** * 复制一棵树 * @param rootNode * @return */ public static &lt;T&gt; TreeNode&lt;T&gt; copyTree(TreeNode&lt;T&gt; rootNode) &#123; TreeNode&lt;T&gt; newNode = null; TreeNode&lt;T&gt; leftNode = null; TreeNode&lt;T&gt; rightNode = null; if(null == rootNode)&#123; return null; &#125; //复制左子树 if(null != rootNode.getLeftNode())&#123; leftNode = copyTree(rootNode.getLeftNode()); &#125; //复制右子树 if(null != rootNode.getRightNode())&#123; rightNode = copyTree(rootNode.getRightNode()); &#125; newNode = new TreeNode&lt;T&gt;(); newNode.setData(rootNode.getData()); newNode.setLeftNode(leftNode); newNode.setRightNode(rightNode); return newNode; &#125; public static void main(String[] args) &#123; TreeNode&lt;String&gt; treeNode = TreeUtils.createTree(); System.out.println("先序输出"); printXianXu(treeNode); System.out.println("中序输出"); printZhongXu(treeNode); System.out.println("后序输出"); printHouXu(treeNode); System.out.println("高度：" + treeDepth(treeNode)); System.out.println("节点数：" + sumNodes(treeNode)); System.out.println("叶子节点数：" + sumLeafNodes(treeNode)); TreeNode&lt;String&gt; copyTree = copyTree(treeNode); System.out.println("先序输出"); printXianXu(copyTree); &#125; &#125; B树、B+树平衡多路查找树，不是很懂，只知道常用于文件系统。可以参阅《MySQL索引背后的数据结构及算法原理》一文。 树、森林与二叉树的转换把树或森林转换成成对应的二叉树。其转换成二叉树的核心思想是二叉树的结点，左边挂孩子，右边挂兄弟。把二叉树还原成对应的树或森林，也是用同样的原理去还原即可。 非线性结构-图图的算法比较复杂，了解了一些概念以及图常用算法的原理。并没有写出代码。有向图、无向图、强连通图、存储结构的邻接矩阵和邻接表、遍历算法的深度优先和广度优先、最小生成树的普利姆算法及克鲁斯卡尔算法、最短路径的迪杰斯特拉算法、拓扑排序等。了解一下这些概念，并能在纸上能够大致画出过程图。还真总结不出什么。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构中一些示例代码的实现]]></title>
    <url>%2F2018%2F04%2F10%2Fimplement%2F</url>
    <content type="text"><![CDATA[科学的研究方法（摘录至文明之光一书） 不盲从，不接受任何自己不清楚的真理。不管有什么权威的结论，只要没有经过自己的研究，都可以怀疑。 对于复杂的问题，尽量分解为多个简单的小问题来研究，一个一个地分开解决。 解决这些小问题时，应该按照先易后难的次序，逐步解决。 解决每个小问题之后，再综合起来。看看是否彻底解决了原来的问题。 内存溢出和内存泄露内存溢出内存溢出主要是指，要装的数据要超过容器本身了，这是则会导致溢出。类似与生活中的水桶、杯子等，容量是有限的，所以不能进行无限的填装。像Java中的OOM，就属于内存溢出。因为Java中GC的存在，所以并不会发生内存泄露。 内存泄露上一章用到C语言制造链表，对于链表中结点的删除操作，会有一个free()函数的调用。free()函数的作用是释放内存空间。所谓的释放内存空间，是指把对内存地址的操作权限移交给操作系统。如果没有做free()这个操作，删除该结点时，会导致该结点在已经无法找到了，但却还拥有控制权限。操作系统在分配内存时，会认为当前内存地址有人还在使用，就不会分配给其他的应用程序，从而会导致内存空间，越用越少。 排序排序的稳定性所谓稳定性是指，如果序列中两个数据元素相等，即r[i]==r[j]，排序前r[i]在r[j]前，排序后r[i]仍然在r[j]前，则这个排序算法是稳定的，反之是不稳定的。 选择排序其基本思想是从待排序的无序区中找出最小的元素，将该元素与该区中的第一个元素交换位置。该排序算法是不稳定的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package datastructure.part.sort;import java.util.Arrays;/** * @description * @author Denghs * @version 1.0,2018年2月27日 上午9:27:32 * @remark * 选择排序：每一次在无序的序列中选出关键字最小的记录，依次存放在已排好序的记录序列最后。 * 原始 数据：5 4 9 87 1 2 14 26 * 第一趟 1 5 4 9 87 2 14 26 * 第二趟 1 2 5 4 9 87 14 26 * 第三趟 1 2 4 5 9 87 14 26 * 第四趟 1 2 4 5 9 87 14 26 * 第五趟 1 2 4 5 9 87 14 26 * 第六趟 1 2 4 5 9 14 87 26 * 第七趟 1 2 4 5 9 14 26 87 */public class ChooseSort &#123; public static void main(String[] args) &#123; //统计运行次数 int count = 0; int[] array = &#123; 5, 4, 9, 87, 1, 2, 14, 26 &#125;; chooseSort(array, count); &#125; /** * 选择排序 * @param array * @param count */ public static void chooseSort(int[] array, int count) &#123; for (int i = 0; i &lt; array.length; i++) &#123; for (int j = i + 1; j &lt; array.length; j++) &#123; if(array[j] &lt; array[i])&#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; count++; &#125; &#125; System.out.println(Arrays.toString(array) + "---&gt;ChooseSort：" + count); &#125;&#125; 插入排序其核心思想是把待排序区中的第一个元素拿出来，把位置给空出来。然后用该元素，跟有序区中的元素进行比较。假设是从小到大排序，则比该元素大的，往后移动一次。依次进行即可。把该元素插入到不能移动的元素后边的空间中。该排序算法是稳定的。12345678910111213141516171819202122232425262728293031323334353637383940414243package datastructure.part.sort;import java.util.Arrays;/** * @description * @author Denghs * @version 1.0,2018年2月27日 上午9:57:20 * @remark 插入排序：1、元素拿出来。2、符合条件的元素后移 */public class InsertSort &#123; public static void main(String[] args) &#123; // 统计运行次数 int count = 0; int[] array = &#123; 5, 4, 9, 87, 1, 2, 14, 26 &#125;; insertSort(array, count); &#125; /** * 插入排序 * @param array * @param count */ public static void insertSort(int[] array, int count) &#123; int pos = 0; for (int i = 2; i &lt; array.length; i++) &#123; // 待插入的位置 pos = i; // 元素拿出来 int temp = array[i]; for (int j = i - 1; j &gt;= 0 &amp;&amp; array[j] &gt; temp; j--) &#123; // 符合条件的元素后移 array[j + 1] = array[j]; // 需要插入的位置 pos = j; count++; &#125; array[pos] = temp; &#125; System.out.println(Arrays.toString(array) + "---&gt;InsertSort：" + count); &#125;&#125; 冒泡排序其基本思想是通过相邻元素之间的比较和交换，来完成排序。有向上冒泡和向下下沉。该排序算法是稳定的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130package datastructure.part.sort;import java.util.Arrays;/** * @description * @author Denghs * @version 1.0,2018年2月27日 上午10:41:21 * @remark 冒泡排序：相邻元素之间的比较交换。一种是向上冒泡，一种是向下下沉 */public class BubbleSort &#123; public static void main(String[] args) &#123; // 统计运行次数 int count = 0; int[] array1 = &#123; 5, 4, 9, 87, 1, 2, 14, 26 &#125;; int[] array2 = &#123; 5, 4, 9, 87, 1, 2, 14, 26 &#125;; int[] array3 = &#123; 5, 4, 9, 87, 1, 2, 14, 26 &#125;; int[] array4 = &#123; 5, 4, 9, 87, 1, 2, 14, 26 &#125;; count = bubbleSort1(array1, 0); System.out.println(Arrays.toString(array1) + "---&gt;bubbleSort1：" + count); count = bubbleSort2(array2, 0); System.out.println(Arrays.toString(array2) + "---&gt;bubbleSort2：" + count); count = bubbleSort3(array3, 0); System.out.println(Arrays.toString(array3) + "---&gt;bubbleSort3：" + count); count = bubbleSort4(array4, 0); System.out.println(Arrays.toString(array4) + "---&gt;bubbleSort4：" + count); int[] array5 = &#123; 1, 2, 4, 3, 5, 6, 7, 8 &#125;; count = bubbleSort4(array5, 0); System.out .println(Arrays.toString(array5) + "---&gt;bubbleSort4：" + count); &#125; /** * 向上冒泡 * * @param array * @param count */ public static int bubbleSort1(int[] array, int count) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; for (int j = 1; j &lt; array.length - i; j++) &#123; if (array[j] &lt; array[j - 1]) &#123; int temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; &#125; count++; &#125; &#125; return count; &#125; /** * 向下下沉 * * @param array * @param count */ public static int bubbleSort2(int[] array, int count) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; for (int j = array.length - 1; j &gt; i; j--) &#123; if (array[j] &lt; array[j - 1]) &#123; int temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; &#125; count++; &#125; &#125; return count; &#125; /** * 向上冒泡，优化 * * @param array * @param count */ public static int bubbleSort3(int[] array, int count) &#123; // 标记，true表示：元素还没有排好序 boolean flag = true; for (int i = 0; i &lt; array.length - 1 &amp;&amp; flag; i++) &#123; // 认为已经排好序 flag = false; for (int j = 1; j &lt; array.length - i; j++) &#123; if (array[j] &lt; array[j - 1]) &#123; int temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; // 元素执行了交换，则说明数据还没有排好序 flag = true; &#125; count++; &#125; &#125; return count; &#125; /** * 向下下沉：优化 * * @param array * @param count */ public static int bubbleSort4(int[] array, int count) &#123; // 标记，true表示：元素还没有排好序 boolean flag = true; for (int i = 0; i &lt; array.length - 1 &amp;&amp; flag; i++) &#123; // 认为已经排好序 flag = false; for (int j = array.length - 1; j &gt; i; j--) &#123; if (array[j] &lt; array[j - 1]) &#123; int temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; // 元素执行了交换，则说明数据还没有排好序 flag = true; &#125; count++; &#125; &#125; return count; &#125;&#125; 希尔排序其核心思想是对数据进行分组，然后再对分组后的数据进行插入排序算法。该排序算法是不稳定的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package datastructure.part.sort;import java.util.Arrays;/** * @description * @author Denghs * @version 1.0,2018年2月27日 下午3:23:48 * @remark 希尔排序：对数据进行分组，然后再进行插入排序算法 */public class ShellSort &#123; public static void main(String[] args) &#123; // 统计运行次数 int count = 0; int[] array = &#123; 5, 4, 9, 87, 1, 2, 14, 26 &#125;; shellSort(array, count); &#125; /** * 希尔排序 * @param array * @param count */ public static void shellSort(int[] array, int count) &#123; int gap = array.length; int pos = 0; do &#123; //业界统一实验 平均最好间隔情况 gap = gap / 3 + 1; for (int i = gap; i &lt; array.length; i += gap) &#123; // 待插入的位置 pos = i; // 元素拿出来 int temp = array[i]; for (int j = i - gap; j &gt;= 0 &amp;&amp; array[j] &gt; temp; j -= gap) &#123; // 符合条件的元素后移 array[j + gap] = array[j]; // 需要插入的位置 pos = j; count++; &#125; array[pos] = temp; &#125; &#125; while (gap &gt; 1); System.out.println(Arrays.toString(array) + "---&gt;ShellSort：" + count); &#125;&#125; 快速排序其基本思想是从待排序序列中找一个基准数，以基准数进行左右分区，其中一部分的所有数据都比另外一部分所以数据小，基准数排在两个分区序列中间。然后再按此方法对这两部分数据分别进行快速排序，递归进行，达到变成有序序列。该排序算法是不稳定的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package datastructure.part.sort;import java.util.Arrays;/** * @description * @author Denghs * @version 1.0,2018年2月27日 下午4:30:56 * @remark 快速排序：用一个PV值，跟PV值进行比较来分区，小的放左边，大的放右边。对分过区的，再找PV值进行分区，直到分区只有一个元素 */public class QuickSort &#123; public static void main(String[] args) &#123; int[] array = &#123; 5, 4, 9, 87, 1, 2, 14, 26 &#125;; quickSort(array); System.out.println(Arrays.toString(array) + "---&gt;QuickSort"); &#125; /** * @param array */ public static void quickSort(int[] array) &#123; qSort(array, 0, array.length - 1); &#125; /** * * @param array * @param low * @param hight */ public static void qSort(int[] array, int low, int hight) &#123; if (low &lt; hight) &#123; int pivot = partition(array, low, hight); // 对左区间序列排序 qSort(array, low, pivot - 1); // 对右区间序列排序 qSort(array, pivot + 1, hight); &#125; &#125; /** * 分区 * @param array * @param low * @param hight * @return */ public static int partition(int[] array, int low, int hight) &#123; // 用分区后的第一个元素作为PV值 int pv = array[low]; while (low &lt; hight) &#123; while (low &lt; hight &amp;&amp; array[hight] &gt;= pv) &#123; // 比基准数大，本来就在右边，所以hight向前移动 hight--; &#125; if (low &lt; hight) &#123; array[low] = array[hight]; low++; &#125; while (low &lt; hight &amp;&amp; array[low] &lt;= pv) &#123; // 比基准数小，本来就在左边，所以low向前移动 low++; &#125; if (low &lt; hight) &#123; array[hight] = array[low]; hight--; &#125; &#125; //把拿出来的PV数，放回到low的位置 array[low] = pv; return low; &#125;&#125; 归并排序其基本思想是使用辅助空间，首先是对待排序序列进行拆分，以递归的方式，拆成只剩下一个的时候，再两两进行归并操作，按指定的条件进行排序。再执行最后一次归并时，如果最后一次比较后，某个序列中有多余的元素，会直接插入到辅助空间后面。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package datastructure.part.sort;import java.util.Arrays;/** * @description * @author Denghs * @version 1.0,2018年2月27日 下午7:24:42 * @remark 归并排序：两两归并 */public class MergeSort &#123; public static void main(String[] args) &#123; int[] array = &#123; 5, 4, 9, 87, 1, 2, 14, 26 &#125;; mergeSort(array); System.out.println(Arrays.toString(array) + "---&gt;MergeSort"); &#125; /** * @param array */ public static void mergeSort(int[] array) &#123; mSort(array, array, 0, array.length - 1, array.length); &#125; /** * 归并排序 * @param src：源数组 * @param des：目标数组 * @param low：最低位 * @param hight：最高位 * @param max：最大值 */ public static void mSort(int[] src, int[] des, int low, int hight, int max) &#123; if (low == hight) &#123; // 只有一个元素，不需要归并 des[low] = src[low]; &#125; else &#123; // 如果多个元素，进行两路划分 int[] space = new int[max]; int mid = (low + hight) / 2; mSort(src, space, low, mid, max); mSort(src, space, mid + 1, hight, max); // 当剩下一个元素时，递归划分结束。开始进行merge归并操作 merge(space, des, low, mid, hight); &#125; &#125; /** * 两两合并 * @param src * @param des * @param low * @param mid * @param hight */ public static void merge(int[] src, int[] des, int low, int mid, int hight) &#123; int i = low; int j = mid + 1; int k = low; // 将小的放到目的地中 while (i &lt;= mid &amp;&amp; j &lt;= hight) &#123; if (src[i] &lt; src[j]) &#123; des[k++] = src[i++]; &#125; else &#123; des[k++] = src[j++]; &#125; &#125; // 若还剩几个尾部元素 while (i &lt;= mid) &#123; des[k++] = src[i++]; &#125; // 若还剩几个尾部元素 while (j &lt;= hight) &#123; des[k++] = src[j++]; &#125; &#125;&#125; 查找二分查找法二分查找又称折半查找，效率较高，但有限制条件。只能对线性表的顺序存储结构并且元素有序进行查找。可采用递归、非递归方式。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package datastructure.part.sort;/** * @description * @author Denghs * @version 1.0,2018年2月28日 下午3:18:58 * @remark 二分查找法 */public class BinarySearch &#123; public static void main(String[] args) &#123; int[] array = &#123; 1, 2, 3, 4, 5, 6, 7, 8 &#125;; int index = binarySearch(array, 1, 0, array.length - 1); System.out.println("index：" + index); index = binarySearch(array, 1); System.out.println("index：" + index); &#125; /** * 非递归方式 * @param array * @param keyword * @return */ private static int binarySearch(int[] array, int keyword) &#123; int low = 0; int hight = array.length - 1; int mid; while (low &lt;= hight) &#123; mid = (low + hight) / 2; if (keyword == array[mid]) &#123; return mid; &#125; else if (keyword &lt; array[mid]) &#123; hight = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; return -1; &#125; /** * 递归方式 * @param array * @param keyword * @param low * @param hight * @return */ private static int binarySearch(int[] array, int keyword, int low, int hight) &#123; if (low &lt;= hight) &#123; int mid = (low + hight) / 2; if (keyword == array[mid]) &#123; return mid; &#125; else if (keyword &gt; array[mid]) &#123; return binarySearch(array, keyword, mid + 1, hight); &#125; else &#123; return binarySearch(array, keyword, low, mid - 1); &#125; &#125; return -1; &#125;&#125; 二叉排序树又称二叉查找树，其特点是如果右子树非空，右子树上所有结点的值均大于根节点的值。如果左子树非空，左子树上所有结点的值均小于根结点的值。左右子树又各是一棵二叉排序树。中序遍历即可获得一个有序序列。Java中的TreeSet，其实就是一个二叉排序树，根据左小右大来放置元素。 其他代码实现顺序栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package datastructure.part.one;/** * @description * @author Denghs * @version 1.0,2018年2月8日 上午9:37:53 * @remark 数组结构的顺序栈 */public class Stack&lt;T&gt; &#123; private int maxSize; // 栈空间的大小 private T[] stackArray;// 顺序栈，采用泛型确定栈空间的存放的数据类型 private int top; // 栈顶指针 public Stack(int size) &#123; maxSize = size; stackArray = (T[]) new Object[maxSize]; top = -1; &#125; /** * 入栈 * @param element */ public void push(T element) &#123; stackArray[++top] = element; if (top &gt; (maxSize - 1))&#123; top = maxSize - 1; &#125; &#125; public void pretendedPush() &#123; ++top; if (top &gt; (maxSize - 1)) &#123; top = maxSize - 1; &#125; &#125; /** * 出栈 * @return */ public T pop() &#123; if (top == -1) &#123; return null; &#125; else &#123; return stackArray[top--]; &#125; &#125; /** * 查看栈顶元素，但是不出栈 * @return */ public T peek() &#123; return stackArray[top]; &#125; /** * 判断栈是否空 * @return */ public boolean isEmpty() &#123; return top == -1; &#125; /** * 判断栈是否满 * @return */ public boolean isFull() &#123; return top == maxSize - 1; &#125;&#125; 进制转换借助栈空间，根据基数对原数取余数，把取到余数入栈，再对原数取整，循环该过程，直到取整的数为0时停止。最后再栈内元素全部出栈。12345678910111213141516171819202122232425262728293031323334package datastructure.part.one;/** * @description * @author Denghs * @version 1.0,2018年4月7日 上午9:17:33 * @remark 进制转换 */public class BinaryConversion &#123; public static void main(String[] args) &#123; conversion(6, 2); &#125; /** * 进制转换的思想是，对一个原数不停的取余数 * @param number：原始数值 * @param decimalBinary：转换的进制，基数 */ public static void conversion(int number, int decimalBinary) &#123; // 初始化栈空间，栈的大小。取数值整除基数再加1 Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(number / decimalBinary + 1); while (number != 0) &#123; // 把余数放入栈中 stack.push(number % decimalBinary); // 取整 number = number / decimalBinary; &#125; while (!stack.isEmpty()) &#123; System.out.print(stack.pop()); &#125; &#125;&#125; 判断回文数回文的特点是：倒着写跟原来是一样的。代码的实现，用了三种方式。第一种是判断非负整数是否是个回文数。采用的方式，是把原来的数值给回转过来，再跟原数值进行一次比较，相等则是回文数。第二种是采用栈，对数值的长度进行劈叉，把前一半的数值一次入栈。然后再进行出栈，并与后一半数值进行比较，都相等则是回文数。该方式有一个BUG，当长度是奇数时，前一半数据的长度跟后一半数据的长度并不相等，会导致12321这种类型的数据，判断出来不是回文数。第三种是获取数据的字节数组，采用头指针跟尾指针，每循环一次，拿头指针上的数据与尾指针上的数据进行比较，相等则头指针往前挪一位，尾指针往后挪一位。直到头指针小于等与尾指针，循环结束。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package datastructure.part.one;/** * @description * @author Denghs * @version 1.0,2018年3月5日 下午4:52:12 * @remark 判断回文数 */public class Symmetry &#123; public static void main(String[] args) &#123; System.out.println(symmetry(1221)); System.out.println(symmetry("哈哈哈哈")); System.out.println(symmetry("456654")); System.out.println(symmetryStr("45654")); &#125; /** * 判断一个数值是否是回文数。回文的特点是：倒着写跟原来是一样的。 * * @param number */ public static boolean symmetry(int number) &#123; int i = 0; int sum = 0; int record = number;// 保存原记录数 while (true) &#123; i = number % 10; sum = sum * 10 + i; number /= 10; if (number == 0) break; &#125; // 判断倒过来写的数，是否跟原来的数是一样的。 if (sum == record) &#123; return true; &#125; else &#123; return false; &#125; &#125; /** * 判断一个串是否是回文串。回文的特点是：倒着写跟原来是一样的。 * 使用栈的方式，进行比较。如果串的长度是一个奇数，会存在一个中间数没有对应的数进行比较。 * 则会返回false * @param string */ public static boolean symmetry(String string) &#123; // 获取串字符的长度 char[] charArray = string.toCharArray(); // 初始化栈 Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(charArray.length / 2 + 1); for (int i = 0; i &lt; charArray.length / 2; i++) &#123; // 前一半的字符放入栈中 stack.push(charArray[i]); &#125; for (int j = charArray.length / 2; j &lt; charArray.length; j++) &#123; Character character = stack.pop(); // 栈内已经没有元素了或者有字符不相同 if (null == character || character != charArray[j]) &#123; return false; &#125; &#125; return true; &#125; /** * 判断一个串是否是回文串。回文的特点是：倒着写跟原来是一样的。 * @param string */ public static boolean symmetryStr(String string) &#123; char[] charArray = string.toCharArray(); int start = 0; int end = charArray.length - 1; while (start &lt;= end) &#123; if (charArray[start] != charArray[end]) &#123; return false; &#125; start++; end--; &#125; return true; &#125;&#125; 汉诺塔问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package datastructure.part.one;import java.util.Scanner;/** * @description * @author Denghs * @version 1.0,2018年2月7日 上午9:37:53 * @remark 汉诺塔问题 */public class HanNuoTa &#123; public static void main(String[] args) &#123; System.out.println("输入一个数字："); Scanner scanner = new Scanner(System.in); //操作数 int number = scanner.nextInt(); //三根柱子 String poleA = "柱子A"; String poleB = "柱子B"; String poleC = "柱子C"; //A柱子上的盘子，借助B柱子，移动到C柱子 hanNuoTa(number, poleA, poleB, poleC); scanner.close(); &#125; /** * @param number 盘子数 * @param poleA 盘子所在的柱子 * @param poleB 需要借力的柱子 * @param poleC 最终移动到的柱子 */ private static void hanNuoTa(int number, String poleA, String poleB, String poleC) &#123; /* 如果是1个盘子 直接将A柱子上的盘子从A移动到C 否则 先将A柱子上的n-1个盘子，借助C移动B 直接将A柱子上的盘子从A移动到C 最后将B柱子上的n-1个盘子，借助A移动C*/ if(1 == number)&#123; System.out.println("将编号为-" + number + "的盘子，直接从柱子-" + poleA + "移动到柱子-" + poleC); &#125;else&#123; hanNuoTa(number-1, poleA, poleC, poleB); System.out.println("将编号为-" + number + "的盘子，直接从柱子-" + poleA + "移动到柱子-" + poleC); hanNuoTa(number-1, poleB, poleA, poleC); &#125; &#125; &#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[回顾数据结构的基础知识]]></title>
    <url>%2F2018%2F03%2F12%2Fdata_struct%2F</url>
    <content type="text"><![CDATA[之前在写Java中的容器时，有写到一些关于数据结构的部分，可以参考《Java的List、Set、Map容器》一文。这里再详细回顾一下对数据结构的学习。 C语言及指针回顾字节：存储数据的单元，是硬件所能访问的最小单位。1字节=8位，1k=1024字节，1M=1024k，1G=1024M。对于4G内存的电脑来说，所能存放数据最多是（4*1024*1024*1024*8）位的二进制数据。物理内存地址：内存单元的编号，从零开始的非负整数指针：指针就是地址，地址就是指针。指针变量：存放内存单元编号的变量，就是存放地址的变量。结构体：把一些基本类型数据组合在一起，形成一个新的复合数据类型。一个指针变量，无论它指向的变量占几个字节，该指针变量本身只占4个字节。用第一个字节的地址表示整个变量的地址。一个变量的地址是用该变量首字节的地址来表示。CPU通过地址总线、控制总线、数据总线，俗称三根总线，来操作物理内存。 看懂一个程序的三个步骤 程序的流程 每个语句的功能 试数 问题规模的增加，算法对运算处理的性能消耗123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package datastructure.part.one;import java.util.Arrays;/** * @description * @author Denghs * @version 1.0,2017年11月23日 下午2:43:18 * @remark */public class TestOn &#123; public static void main(String[] args) &#123; long n = 10000; method1(n); method2(n); long start = System.currentTimeMillis(); long sum = method3(n); System.out.println("method3：" + (System.currentTimeMillis() - start) + "毫秒，sum=" + sum); &#125; /** * 用for循环进行1+2+3+...+100的计算。 该方法的时间复杂度是O（n） * @param n */ public static void method1(long n) &#123; long start = System.currentTimeMillis(); long sum = 0; for (long i = 1; i &lt;= n; i++) &#123; sum += i; &#125; System.out.println("method1： " + (System.currentTimeMillis() - start) + "毫秒，sum=" + sum); &#125; /** * 用高斯公式进行1+2+3+...+100的计算。 该方法的时间复杂度是O（1） * @param n */ public static void method2(long n) &#123; long start = System.currentTimeMillis(); long sum = (n + 1) * n / 2; System.out.println("method2： " + (System.currentTimeMillis() - start) + "毫秒，sum=" + sum); &#125; /** * 用递归的方式计算1+2+3+...+100的和。数值过大，会导致内存溢出，递归本质是函数的不停的压栈、出栈的操作 * @param n */ public static long method3(long n) &#123; if(n == 1)&#123; return 1; &#125;else&#123; return n + method3(n-1); &#125; &#125;&#125; 从上图的运行结果可以明显的看到，当问题计算的规模n=10000时，好像method1、method2、method3彼此的计算耗时都是0毫秒。但是当n再扩大10倍时，method1花了2毫秒，method3直接抛异常了，而method2而然是0毫秒。method1是用for循环的方式，method2则是高斯公式，method3是用递归的方式。在数据结构领域，关于算法的时间复杂度，有一个计算公式，大O表示法。这里不做过多说明，教科书上有该公式的计算方法跟定论。 线性结构数据结构中关于数据的逻辑结构，只分为线性结构、非线程结构。所谓的线性结构，我们可以用一个生活化的场景来理解它，用穿好线的针能够一次把元素都串起来。线性结构是指元素只能有一个顶点、一个端点，中间的元素只有一个前驱跟一个后继。 顺序表可以把串在一起的元素，紧紧的挤压在一个方向。让元素紧挨着元素。这就可以理解成是一个顺序表。顺序表其实就是数组，一次给一片连续的空间，然后把空间按一个一个的小格子划分好。其特点是：当CPU在内存中找不到连续一片的符合要求的空间，会导致分配失败。可以通过存放元素格子的宽度，也就是偏移量乘以第几个元素，获取指定地址空间上的元素。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;//连续存储数组的算法struct Arr&#123; int * pBase; //存储容器中第一个元素的地址 int capacity; //所能容纳元素的最大容量 int length; //当前有效元素的个数&#125;;void init_arr(struct Arr *, int capacity);//初始化容器bool append_arr(struct Arr *, int value);//追加元素bool insert_arr(struct Arr *, int index, int value);//在指定的角标处插入元素bool delete_arr(struct Arr *, int index, int * delete_value);//删除指定角标处的元素，并返回被删除的元素的值int get(struct Arr *, int index);//获取指定角标的元素bool is_empty(struct Arr *);//容器是否空bool is_full(struct Arr *);//容器是否已满void sort_arr(struct Arr *);//按元素的值自然排序void print_arr(struct Arr *);//输出元素的值void invert_arr(struct Arr *);//元素值前后倒置void main()&#123; int delete_value; int get_value; struct Arr array; init_arr(&amp;array, 10); print_arr(&amp;array); printf("\n-------分隔符-追加-----\n"); append_arr(&amp;array, 10); append_arr(&amp;array, 6); append_arr(&amp;array, 2); append_arr(&amp;array, -1); append_arr(&amp;array, 9); print_arr(&amp;array); printf("\n-------分隔符-插入-----\n"); insert_arr(&amp;array, 0, 7); //insert_arr(&amp;array, 6, -18); //insert_arr(&amp;array, 1, 72); print_arr(&amp;array); /**printf("\n-------分隔符-删除-----\n"); bool flag = delete_arr(&amp;array, 5, &amp;delete_value); print_arr(&amp;array); if(flag)&#123; printf("被删除的元素的值：%d\n", delete_value); &#125; printf("\n-------分隔符-获取-----\n"); get_value = get(&amp;array, 5); printf("角标 %d 的元素值：%d\n", 5 ,get_value); get_value = get(&amp;array, 0); printf("角标 %d 的元素值：%d\n", 0 ,get_value); printf("\n-------分隔符-倒置-----\n"); invert_arr(&amp;array); print_arr(&amp;array); printf("\n-------分隔符-排序-----\n"); sort_arr(&amp;array); print_arr(&amp;array);*/ &#125;//初始化容器void init_arr(struct Arr * pArr, int capacity)&#123; pArr-&gt;pBase = (int *)malloc(sizeof(int) * capacity);//动态分配内存 if(NULL == pArr-&gt;pBase)&#123; printf("动态分配内存失败！\n"); exit(-1);//程序退出。跟Java中的System.exit(-1);一样 &#125; pArr-&gt;capacity = capacity; pArr-&gt;length = 0;//未存储元素，有效元素为0个&#125;//输出元素的值void print_arr(struct Arr * pArr)&#123; printf("容器大小为：%d，有效元素个数为：%d\n", pArr-&gt;capacity, pArr-&gt;length); if(is_empty(pArr))&#123; printf("空容器！\n"); &#125;else&#123; for(int i=0; i&lt;pArr-&gt;length; i++)&#123; printf("%d ", pArr-&gt;pBase[i]); &#125; printf("\n"); &#125;&#125;//容器是否空bool is_empty(struct Arr * pArr)&#123; //有效元素的个数为0 return pArr-&gt;length == 0 ? true:false;&#125;//容器是否已满bool is_full(struct Arr * pArr)&#123; //有效元素的个数=容器的长度 return pArr-&gt;length == pArr-&gt;capacity ? true:false;&#125;//追加bool append_arr(struct Arr * pArr, int value)&#123; //如果容器满了 if(is_full(pArr))&#123; return false; &#125; //在当前容器的最后一个位置处追加元素 pArr-&gt;pBase[pArr-&gt;length] = value; pArr-&gt;length++; return true;&#125;//在指定的角标处插入元素bool insert_arr(struct Arr * pArr, int index, int value)&#123; int i = 0; //如果容器满了 if(is_full(pArr))&#123; printf("容器已满！\n"); return false; &#125; //index的值不能是负数，不是超过容器存储的有效元素个数 //index=有效元素个数时，表示在最后一个元素处追加一个元素值 if(index &lt; 0 || index &gt; pArr-&gt;length)&#123; return false; &#125; //先移位，把指定角标位及该角标之后存放的元素，往后挪一个位子存放 for(i = pArr-&gt;length - 1; i &gt;= index; i--)&#123; pArr-&gt;pBase[i+1] = pArr-&gt;pBase[i]; &#125; //把值存入指定角标处 pArr-&gt;pBase[index] = value; pArr-&gt;length++; return true;&#125;//删除指定角标处的元素，并返回被删除的元素的值bool delete_arr(struct Arr * pArr, int index, int * delete_value)&#123; int i; //如果容器满了 if(is_empty(pArr))&#123; printf("容器已空！\n"); return false; &#125; //index的值不能是负数，不是超过容器存储的有效元素个数 if(index &lt; 0 || index &gt; pArr-&gt;length-1)&#123; return false; &#125; //把要删除的指定角标处的值取出来 *delete_value = pArr-&gt;pBase[index]; //需要移位，要删除的指定角标之后的值需要往前移动一位 for(i = index + 1; i &lt; pArr-&gt;length; i++)&#123; pArr-&gt;pBase[i-1] = pArr-&gt;pBase[i]; &#125; pArr-&gt;length--; return true;&#125;//获取指定角标位置的元素值int get(struct Arr * pArr, int index)&#123; //index的值不能是负数，不是超过容器存储的有效元素个数 if(index &lt; 0 || index &gt; pArr-&gt;length-1)&#123; //应该是Java中的数组角标越界异常，不能确定此处返回的值是否是一个有效的值 return -1; &#125; return pArr-&gt;pBase[index];&#125;//元素值前后倒置void invert_arr(struct Arr * pArr)&#123; int start = 0; int end = pArr-&gt;length-1; int temp; while(start &lt; end)&#123; temp = pArr-&gt;pBase[start]; pArr-&gt;pBase[start] = pArr-&gt;pBase[end]; pArr-&gt;pBase[end] = temp; start++; end--; &#125;&#125;//按元素的值自然排序void sort_arr(struct Arr * pArr)&#123; int i, j, temp; for(i = 0; i&lt;pArr-&gt;length; i++)&#123; for(j=i+1; j&lt;pArr-&gt;length; j++)&#123; if(pArr-&gt;pBase[i] &gt; pArr-&gt;pBase[j])&#123; temp = pArr-&gt;pBase[j]; pArr-&gt;pBase[j] = pArr-&gt;pBase[i]; pArr-&gt;pBase[i] = temp; &#125; &#125; &#125;&#125; 链式结构可以把串在一起的元素，中间的线还流出一点点来。只要顺着线能找到元素。这就可以理解成是一个链式结构。每一个数据元素的地址可以是分散开来的，动态分配，彼此通过指针相连。每个结点只有一个后续结点，首结点没有前驱，尾结点没有后续。链式结构，也就是俗称的链表。对于链表的操作，额外增加一个头结点，以方便对整个链表的操作。头结点跟头指针是两个不同的概念。头结点的数据域部分是空的。 单链表在单链表的结构中，数据元素要有两部分，一部分存放数据元素的数据部分，一部分存放下一个数据元素的地址。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;typedef struct Node&#123; int data;//数据域 struct Node * pNext;//指针域&#125;NODE, *PNODE;//创建链表PNODE creat_list();//输出链表void print_list(PNODE);//是否为空链表bool is_empty(PNODE);//获取链表的长度int get_len(PNODE);//对链表进行排序：按自然顺序void sort_list(PNODE);//插入结点bool insert_node(PNODE,int,int);//删除结点bool delete_node(PNODE,int,int*);void main()&#123; int len; int deleteVal; PNODE pHead = NULL; pHead = creat_list(); //输出值 print_list(pHead); if(is_empty(pHead))&#123; printf("空链表\n"); &#125;else&#123; printf("链表不为空\n"); &#125; //获取链表长度 len = get_len(pHead); printf("链表的长度为：%d\n", len); //排序 sort_list(pHead); print_list(pHead); //插入 if(insert_node(pHead, 1, 33))&#123; printf("插入成功！\n"); &#125;else&#123; printf("插入失败！\n"); &#125; print_list(pHead); //删除 if(delete_node(pHead, 0, &amp;deleteVal))&#123; printf("删除成功！\n"); &#125;else&#123; printf("删除失败！\n"); &#125; print_list(pHead);&#125;//创建链表PNODE creat_list()&#123; int len; int value; int i; //创建头结点 PNODE pHead = (PNODE)malloc(sizeof(NODE)); if(NULL == pHead)&#123; //创建失败 printf("分配内存失败，程序终止!\n"); exit(-1); &#125; printf("请输出链表的结点个数："); scanf("%d", &amp;len); PNODE pTail = pHead; pTail-&gt;pNext = NULL; //循环生成链表的每个节点 for(i=0; i&lt;len; i++)&#123; printf("请输出第%d个结点的值：", i+1); scanf("%d", &amp;value); //创建一个新的结点 PNODE pNew = (PNODE)malloc(sizeof(NODE)); pNew-&gt;data = value; pTail-&gt;pNext = pNew; pNew-&gt;pNext = NULL; pTail = pNew; &#125; return pHead;&#125;//输出链表void print_list(PNODE pHead)&#123; PNODE p = pHead-&gt;pNext; while(NULL != p)&#123; printf("%d ", p-&gt;data); p = p-&gt;pNext; &#125; printf("\n");&#125;//是否为空链表bool is_empty(PNODE pHead)&#123; return NULL == pHead-&gt;pNext ? true:false;&#125;//获取链表的长度int get_len(PNODE pHead)&#123; int len = 0; PNODE p = pHead-&gt;pNext; while(NULL != p)&#123; p = p-&gt;pNext; len++; &#125; return len;&#125;//对链表进行排序：按自然顺序void sort_list(PNODE pHead)&#123; int i, j, temp; //总长度 int len = get_len(pHead); //一个当前节点，一个当前节点的下一个节点 PNODE pNow, pNext; for(i=0, pNow=pHead-&gt;pNext;i&lt;len-1;i++, pNow = pNow-&gt;pNext)&#123; for(j=i+1, pNext = pNow-&gt;pNext;j&lt;len;j++, pNext = pNext-&gt;pNext)&#123; if(pNow-&gt;data &gt; pNext-&gt;data)&#123; //a[i] &gt; a[j] temp = pNow-&gt;data; //temp = a[i] pNow-&gt;data = pNext-&gt;data; //a[i] = a[j] pNext-&gt;data = temp; //a[j] = temp; &#125; &#125; &#125; &#125;//在指定位置插入结点，position从0开始bool insert_node(PNODE pHead, int position, int value)&#123; //获取链表的总长度 //int len = get_len(pHead); //判断position是否是一个有效数。长度是5，position为6，表示是在末尾处添加。index为7，超过有效值 //if(position &gt; len + 1)&#123; //return false; //&#125; int len = 0; //直接定位到需要插入结点的前一结点 PNODE p = pHead; while(NULL != p &amp;&amp; len &lt; position)&#123; p = p-&gt;pNext; len++; &#125; //结点不存在 if(len &gt; position || NULL == p)&#123; return false; &#125; //创建一个新结点 PNODE pNew = (PNODE)malloc(sizeof(NODE)); if(NULL == pNew)&#123; printf("动态内存分配失败！程序退出\n"); exit(-1); &#125; pNew-&gt;data = value; pNew-&gt;pNext = p-&gt;pNext; p-&gt;pNext = pNew; return true;&#125;//删除指定位置的结点，position从0开始bool delete_node(PNODE pHead, int position ,int* deleteVal)&#123; int len = 0; //直接定位到需要插入结点的前一结点 PNODE p = pHead; while(NULL != p-&gt;pNext &amp;&amp; len &lt; position)&#123; p = p-&gt;pNext; len++; &#125; if(len &gt; position || NULL == p-&gt;pNext)&#123; return false; &#125; //要删除的结点 PNODE q = p-&gt;pNext; *deleteVal = q-&gt;data; //把p的指针域指向要删除结点的下一个节点 p-&gt;pNext = p-&gt;pNext-&gt;pNext; //释放删除结点的内存空间 free(q); q = NULL; return true;&#125; 双链表在双链表的结构中，数据元素要有三部分，一部分存放数据元素的数据部分，一部分存放下一个数据元素的地址，一部分存放上一个数据元素的地址。 线性结构的应用-队列、栈队列操作受限的线性表，也称先进先出表。队尾插入，队头取出元素。在非空队列中，队头指针始终指向队头元素，队尾指针始终指向队尾元素的下一个位置。 循环队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;//循环队列，先进先出typedef struct Queue&#123; int * pBase;//动态数组 int front;//队列中有效元素的头元素 int rear;//队列中有效元素的尾元素&#125;QUEUE;//初始化循环队列void init(QUEUE *);//入队，在队列有效元素的尾部添加bool add(QUEUE *, int);//出队，从队头开始获取bool get(QUEUE *, int *);//是否已经满bool isFull(QUEUE *);//是否已经空bool isEmpty(QUEUE *);//打印元素void print(QUEUE *);void main()&#123; QUEUE q; int delValue; init(&amp;q); add(&amp;q, 1); add(&amp;q, 2); add(&amp;q, 3); add(&amp;q, 4); add(&amp;q, 5); add(&amp;q, 6); add(&amp;q, 7); add(&amp;q, 8); print(&amp;q); get(&amp;q, &amp;delValue); printf("1出队的值为：%d\n", delValue); get(&amp;q, &amp;delValue); printf("2出队的值为：%d\n", delValue); get(&amp;q, &amp;delValue); printf("3出队的值为：%d\n", delValue); get(&amp;q, &amp;delValue); printf("4出队的值为：%d\n", delValue); get(&amp;q, &amp;delValue); printf("5出队的值为：%d\n", delValue); get(&amp;q, &amp;delValue); printf("6出队的值为：%d\n", delValue); add(&amp;q, 8); add(&amp;q, 9); get(&amp;q, &amp;delValue); printf("7出队的值为：%d\n", delValue);&#125;//初始化循环队列void init(QUEUE * pQueue)&#123; pQueue-&gt;pBase = (int *) malloc(sizeof(int) * 6); pQueue-&gt;front = 0; pQueue-&gt;rear = 0;&#125;//入队，在队列有效元素的尾部添加bool add(QUEUE * pQueue, int value)&#123; if(isFull(pQueue))&#123; printf("队列已经放满了！\n"); return false; &#125;else&#123; pQueue-&gt;pBase[pQueue-&gt;rear] = value; pQueue-&gt;rear = (pQueue-&gt;rear + 1) % 6; return true; &#125;&#125;//出队，从队头开始获取bool get(QUEUE * pQueue, int * delValue)&#123; if(isEmpty(pQueue))&#123; printf("队列已经空了！\n"); return false; &#125;else&#123; *delValue = pQueue-&gt;pBase[pQueue-&gt;front]; pQueue-&gt;front = (pQueue-&gt;front + 1) % 6; return true; &#125;&#125;//是否已经满bool isFull(QUEUE * pQueue)&#123; if((pQueue-&gt;rear+1) % 6 == pQueue-&gt;front)&#123; return true; &#125; return false;&#125;//是否已经空bool isEmpty(QUEUE * pQueue)&#123; if(pQueue-&gt;rear == pQueue-&gt;front)&#123; return true; &#125; return false;&#125;//打印元素void print(QUEUE * pQueue)&#123; int front = pQueue-&gt;front; //队头数不等于队尾数，则表示一直都有元素 while(front != pQueue-&gt;rear)&#123; printf("%d ", pQueue-&gt;pBase[front]); front = (front+1) % 6; &#125; printf("\n");&#125; 链式栈栈是限定在表的一端进行插入和删除运算的线性表，通常将插入、删除的一端称为栈顶。链式栈，将对链表的操作进行一定的限制，在一端进行插入、删除即可。链式栈，适合开口向上或向下的操作。栈的四种不同操作方式。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;//链表的节点数据对象typedef struct Node&#123; int data;//数据域 struct Node * pNext;//指针域&#125;NODE, * PNODE;//栈--&gt;类似箱子，先进后出typedef struct Stack&#123; PNODE pTop; PNODE pBottom;&#125;STACK, * PSTACK;//初始化栈void init(PSTACK);//压栈bool push(PSTACK, int);//输出栈中的数据void print(PSTACK);//出栈bool pop(PSTACK, int*);//清空void clear(PSTACK);//是否是空栈bool isEmpty(PSTACK);void main()&#123; STACK stack; int value; int i = 0; init(&amp;stack); push(&amp;stack, 1); push(&amp;stack, 2); push(&amp;stack, 3); push(&amp;stack, 4); push(&amp;stack, 5); push(&amp;stack, 6); print(&amp;stack); clear(&amp;stack); if(pop(&amp;stack, &amp;value))&#123; printf("出栈成功！元素值为：%d\n", value); &#125;else&#123; printf("出栈失败！"); &#125; print(&amp;stack);&#125;//初始化栈void init(PSTACK pStack)&#123; pStack-&gt;pTop = (PNODE)malloc(sizeof(NODE)); if(NULL == pStack-&gt;pTop)&#123; printf("分配内存失败!\n"); exit(-1); &#125;else&#123; pStack-&gt;pBottom = pStack-&gt;pTop; pStack-&gt;pTop-&gt;data = NULL; &#125;&#125;//压栈bool push(PSTACK pStack, int value)&#123; //先造一个节点出来 PNODE pNew = (PNODE)malloc(sizeof(NODE)); if(NULL == pNew)&#123; printf("分配内存失败!\n"); return false; &#125;else&#123; pNew-&gt;data = value; pNew-&gt;pNext = pStack-&gt;pTop; pStack-&gt;pTop = pNew; return true; &#125;&#125;//输出栈中的数据void print(PSTACK pStack)&#123; PNODE node = pStack-&gt;pTop; while(node != pStack-&gt;pBottom)&#123; printf("%d ", node-&gt;data); node = node-&gt;pNext; &#125; printf("\n");&#125;//出栈bool pop(PSTACK pStack, int * value)&#123; if(isEmpty(pStack))&#123; printf("已经是空栈了\n"); return false; &#125;else&#123; //要出栈的节点 PNODE node = pStack-&gt;pTop; //出栈节点的值 *value = node-&gt;data; //pTop往下移一个 pStack-&gt;pTop = node-&gt;pNext; //释放出栈节点的内存 free(node); return true; &#125;&#125;//是否是空栈bool isEmpty(PSTACK pStack)&#123; return pStack-&gt;pTop == pStack-&gt;pBottom ? true : false;&#125;//清空void clear(PSTACK pStack)&#123; PNODE p = pStack-&gt;pTop; PNODE q = NULL; while(p != pStack-&gt;pBottom)&#123; q = p-&gt;pNext; //释放内存 free(p); p = q; &#125; pStack-&gt;pTop = pStack-&gt;pBottom;&#125; 顺序表栈顺序表栈，适合开口向左或向右的操作。顺序存储结构，采用数组实现。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package datastructure.part.one;/** * @description * @author Denghs * @version 1.0,2018年2月8日 上午9:37:53 * @remark 数组结构的顺序栈 */public class Stack&lt;T&gt; &#123; private int maxSize; // 栈空间的大小 private T[] stackArray;// 顺序栈，采用泛型确定栈空间的存放的数据类型 private int top; // 栈顶指针 public Stack(int size) &#123; maxSize = size; stackArray = (T[]) new Object[maxSize]; top = -1; &#125; /** * 入栈 * @param element */ public void push(T element) &#123; stackArray[++top] = element; if (top &gt; (maxSize - 1))&#123; top = maxSize - 1; &#125; &#125; public void pretendedPush() &#123; ++top; if (top &gt; (maxSize - 1)) &#123; top = maxSize - 1; &#125; &#125; /** * 出栈 * @return */ public T pop() &#123; if (top == -1) &#123; return null; &#125; else &#123; return stackArray[top--]; &#125; &#125; /** * 查看栈顶元素，但是不出栈 * @return */ public T peek() &#123; return stackArray[top]; &#125; /** * 判断栈是否空 * @return */ public boolean isEmpty() &#123; return top == -1; &#125; /** * 判断栈是否满 * @return */ public boolean isFull() &#123; return top == maxSize - 1; &#125;&#125; 12345678910111213141516171819202122232425package datastructure.part.one;/** * @description * @author Denghs * @version 1.0,2018年4月5日 下午12:06:32 * @remark */public class TestStack &#123; public static void main(String[] args) &#123; Stack&lt;Student&gt; stack = new Stack&lt;Student&gt;(10); stack.push(new Student("张三")); stack.push(new Student("李四")); stack.push(new Student("王五")); stack.push(new Student("麻六")); stack.push(new Student("黑七")); System.out.println(stack.pop().getName()); System.out.println(stack.pop().getName()); System.out.println(stack.pop().getName()); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017年月度目标与进展]]></title>
    <url>%2F2018%2F02%2F13%2Fannual-summary%2F</url>
    <content type="text"><![CDATA[感慨从2017年6月开始创建博客开始，到现在也有近一年了。回首时，还是很感慨。坚持了一年的博客输出，对知识体系的理解，强迫对知识的输入再输出。收获很多，更多的是心历上的收获。坚持做一件自己持续投入的事情，这份收获在于自己的内心感受。不在乎外界看法，不在乎流量，不在乎评价，坚持自己的初衷，知识的输出。 6月目标 个人博客上线 阅读《MySQL5.6从零开始学》系统的补充一下MySQL相关知识 已完成 个人博客上线，从以前的纸质笔记本上摘抄出一些记录，并输出成博客文章 阅读《MySQL5.6从零开始学》 7月###目标 自考报名、报考 阅读《MySQL5.6从零开始学》系统的补充一下MySQL相关知识 阅读教材《Java语言程序设计一》 已完成 完成自考报名、10月报考，中大《计算机网络》专业，计划不报班自学参加考试 阅读《MySQL5.6从零开始学》系统的补充一下MySQL相关知识 阅读教材《Java语言程序设计一》 8月目标 阅读《精进：如何成为一个很厉害的人》 阅读教材《中国近代史纲要》 已完成 完成一篇博客文章的输出 阅读《精进：如何成为一个很厉害的人》 阅读教材《中国近代史纲要》 9月目标 阅读《深入理解Java虚拟机:JVM高级特性与最佳实践》 刷题《Java语言程序设计一》，提炼重点知识 刷题《中国近代史纲要》，提炼并背诵简单题知识 已完成 完成一篇博客文章的输出 阅读《深入理解Java虚拟机:JVM高级特性与最佳实践》 刷题《Java语言程序设计一》 刷题《中国近代史纲要》 10月目标 阅读教材《计算机网络原理》 参加10月自学考试 阅读《刻意练习》 已完成 完成一篇博客文章的输出 阅读教材《计算机网络原理》 参加10月自学考试 《网络工程》没有按照原有计划进行阅读，主要是一时没有摸索出自己的合适的学习方法。其他科目需要记忆的知识量较大 阅读《刻意练习》 11月目标 预估10月考试中的《计算机网络原理》、《网络工程》是没有过的。再次阅读教材《计算机网络原理》 阅读《硅谷之谜》 开始学习《新概念英语一》，每天10个单词 已完成 完成一篇博客文章的输出 阅读教材《计算机网络原理》 阅读《硅谷之谜》 12月目标 刷题《计算机网络原理》，提炼重点知识 温习《C语言程序设计》，为《数据结构》的考试补下基础 阅读教材《网络工程》 阅读《文明之光》第一册 已完成 完成一篇博客文章的输出 刷题《计算机网络原理》，提炼重点知识 补了谭浩强的绿皮书《C语言程序设计》 阅读教材《网络工程》 阅读《文明之光》第一册]]></content>
      <categories>
        <category>随想</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议详解与回顾]]></title>
    <url>%2F2018%2F01%2F19%2Fhttp-protocol%2F</url>
    <content type="text"><![CDATA[HTTP HTTP（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。HTTP请求的有三次握手建立连接，四次挥手断开连接。最终都是为了进行可靠传输服务。这里不做过多说明，如有兴趣，请参阅《TCP/IP详解》三本神书。 HTTP协议的版本：HTTP/1.0、HTTP/1.1版本 HTTP/1.1版本这个版本增加了持久连接，就是说之前版本的协议一次请求就是一次TCP连接，请求完成后这个连接就关闭掉了。众所周知TCP协议是可靠的，建立连接需要3次握手，断开连接需要4次挥手，并且TCP有流量控制和拥塞控制，有慢开始机制，刚建立连接时传输比较慢，这是比较耗费资源的。一个丰富的页面会有许多图片、表单和超链接。这样的话就会有多次的HTTP请求，所以在这个版本上默认不关闭TCP连接也不用声明Connection: keep-alive字段。如果确实要关闭可以指定Connection: close字段。还引入了管道机制，就是说在一个TCP连接里可以同时发送多个HTTP请求，而不必等待上一个请求响应成功再发送。还增加了PUT、PATCH、HEAD、 OPTIONS、DELETE等命令，丰富了客户端和服务端交互动作。还增加了Host字段。 HTTP协议的特点HTTP协议是无状态的就是说每次HTTP请求都是独立的，任何两个请求之间没有什么必然的联系。但是在实际应用当中并不是完全这样的，引入了Cookie和Session机制来关联请求。 多次HTTP请求在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应HTML页面，然后浏览器收到响应之后发现HTML页面还引用了其他的资源，例如，CSS，JS文件，图片等等，还会自动发送HTTP请求这些需要的资源。现在的HTTP版本支持管道机制，可以同时请求和响应多个请求，大大提高了效率。 基于TCP协议HTTP协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节。底层是基于TCP实现的。现在使用的版本当中是默认持久连接的，也就是多次HTTP请求使用一个TCP连接。 代码1234567891011public class TcpSever &#123; public static void main(String[] args) throws Exception &#123; ServerSocket ss = new ServerSocket(10000); Socket s = ss.accept(); InputStream in = s.getInputStream(); byte[] by = new byte[1024]; int len = in.read(by); System.out.println(new String(by, 0, len)); &#125;&#125; 写一个简单的HTML文件，带一个form表单。 请求头get的请求方式1&lt;form action="http://127.0.0.1:10000" method="get"&gt; 123456789GET /?userName=jiujiu&amp;pass=123&amp;sex=nan&amp;hobby=sports&amp;country=CN&amp;province=GZ&amp;area=GZ&amp;btn1=%CC%E1%BD%BB%B1%ED%B5%A5 HTTP/1.1Accept: text/html, application/xhtml+xml, */*Accept-Language: zh-Hans-CN,zh-Hans;q=0.8,en-US;q=0.5,en;q=0.3User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like GeckoAccept-Encoding: gzip, deflateHost: 127.0.0.1:10000DNT: 1Connection: Keep-Alive Get方式的特点：传送的数据量受URL地址栏限制，传输的数据直接拼在URL地址后，以问号开始（?），多参数分隔以与符号开始（&amp;）。直接传输中文会乱码，HTTP头字段只接受ASCII码值数据。jsp中可以通过URLEncoder.encode()转换成ASCII码值。 post的请求方式1&lt;form action="http://127.0.0.1:10000" method="post"&gt; 12345678910111213POST / HTTP/1.1Accept: text/html, application/xhtml+xml, */*Accept-Language: zh-Hans-CN,zh-Hans;q=0.8,en-US;q=0.5,en;q=0.3Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like GeckoAccept-Encoding: gzip, deflateHost: 127.0.0.1:10000Content-Length: 105DNT: 1Connection: Keep-AliveCache-Control: no-cacheuserName=hehe&amp;pass=4321&amp;sex=nan&amp;hobby=sports&amp;country=CN&amp;province=GZ&amp;area=GZ&amp;btn1=%CC%E1%BD%BB%B1%ED%B5%A5 Post方式的特点：传送的数据量无限制。传输的数据是放在请求体中。 常用请求头说明 请求头与请求体的分隔，是以一个空行隔开的。 第一行为请求行，包含请求方式与HTTP协议版本号。 Accept: 浏览器所支持的数据类型。 Accept-Charset: 浏览器所支持的数据类型。 Accept-Encoding: 浏览器支持的压缩格式 Accept-Language: 浏览器支持的语言环境 Host: 想访问哪台主机 If-Modified-Since: 缓存数据的时间。浏览器为了提高性能，一般情况会缓存第一次的请求结果，在缓存数据时间内，会直接找本地缓存数据。 Referer: 客户机是从哪个页面来的。作用：服务器可以做判断，进行防盗链。 Connection: 请求完后是断开还是保持连接。 响应头下图是一个IE插件，HttpWatch捕捉到的一次请求。左边是请求头，右边是响应头。 常用响应头说明1234567891011121314151617181920HTTP/1.1 200 OKServer: bfe/1.0.8.18Date: Wed, 05 Jul 2017 01:49:57 GMTContent-Type: text/html; charset=utf-8Transfer-Encoding: chunkedConnection: keep-aliveVary: Accept-EncodingCache-Control: privateCxy_all: baidu+63b9ff6074957f7dc4b1c7d31442fcfdExpires: Wed, 05 Jul 2017 01:49:46 GMTX-Powered-By: HPHPX-UA-Compatible: IE=Edge,chrome=1Strict-Transport-Security: max-age=172800BDPAGETYPE: 1BDQID: 0xfafa4d1200006790BDUSERID: 0Set-Cookie: BDSVRTM=0; path=/Set-Cookie: BD_HOME=0; path=/Set-Cookie: H_PS_PSSID=1425_21115_17001_23632_20929; path=/; domain=.baidu.comContent-Encoding: gzip 第一行为状态行，状态码用于表示服务器对请求的处理结果。Location: 跳转到哪里，通常是跟状态码302一起出现。Server: 告诉浏览器，服务器型号Content-Encoding: 告诉浏览器，数据的压缩格式Content-Length: 告诉浏览器，回送数据的长度Content-Type: 告诉浏览器，回送数据的类型Content-Language: 语言环境Refresh: 告诉浏览器，定时刷新Content-Dispostion: 告诉浏览器以下载方式打开数据Transfer-Encoding: 数据是以分块方式回送的Expires: -1Cache-Control: no-cachePragma: no-cache后面三个都是控制浏览器不要缓存。 常见的状态码100～199：表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程200～299：表示成功接收请求并已完成整个处理过程，常用200（OK）300～399：为完成请求，客户需进一步细化请求。例如，请求的资源已经移动一个新地址，常用302、304（未改动）和307（暂时重定向）400～499：客户端的请求有错误，常用404（找不到资源）500～599：服务器端出现错误，常用500（内部服务器错误） 响应体响应头与响应体之间也是以一个空行分隔的。响应体的数据都是二进制数据，浏览器能解析。 关于HTTP的常见问题及解答GET和POST的区别 从字面意思和HTTP的规范来看，GET用于获取资源信息而POST是用来更新资源信息。 GET提交请求的数据实体会放在URL的后面，用?来分割，参数用&amp;连接，举个栗子：/index.html?name=wang&amp;login=1 GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。 GET提交的数据不安全，因为参数都会暴露在URL上。 408 Request Timeout和504 Gateway Timeout的区别408是说请求超时，就是建立连接之后再约定的时间内客户端没有发送请求到客户端到服务端。本质上原因在于客户端或者网络拥塞。504是网关超时，是说代理服务器把客户端请求转发到应用服务器后再约定的时间内没有收到应用服务器的响应。本质上原因在于服务端的响应过慢，也有可能是网络问题。 Cookie和Session的区别和联系Cookie和Session都是为了保存客户端和服务端之间的交互状态，实现机制不同，各有优缺点。首先一个最大的区别就是Cookie是保存在客户端而Session就保存在服务端的。Cookie是客户端请求服务端时服务器会将一些信息以键值对的形式返回给客户端，保存在浏览器中，交互的时候可以加上这些Cookie值。用Cookie就可以方便的做一些缓存。Cookie的缺点是大小和数量都有限制；Cookie是存在客户端的可能被禁用、删除、篡改，是不安全的；Cookie如果很大，每次要请求都要带上，这样就影响了传输效率。Session是基于Cookie来实现的，不同的是Session本身存在于服务端，但是每次传输的时候不会传输数据，只是把代表一个客户端的唯一ID（通常是JSESSIONID）写在客户端的Cookie中，这样每次传输这个ID就可以了。Session的优势就是传输数据量小，比较安全。但是Session也有缺点，就是如果Session不做特殊的处理容易失效、过期、丢失或者Session过多导致服务器内存溢出，并且要实现一个稳定可用安全的分布式Session框架也是有一定复杂度的。在实际使用中就要结合Cookie和Session的优缺点针对不同的问题来设计解决方案。]]></content>
      <categories>
        <category>HTTP协议</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[WebService、RPC、微服务的一些认知]]></title>
    <url>%2F2017%2F12%2F21%2Fwebservice%2F</url>
    <content type="text"><![CDATA[跨系统间的数据交互在《应用的变迁》中提到过，随着大量垂直应用系统的诞生。各异构系统之间的通信、交换数据成为需求。同一个应用会有不同的客户端访问,或者不同的应用之间也会相互调用服务。 Socket通信原理图通过IE来访问SocketServer，可以参考《HTTP协议详解与回顾》一文。程序员都是一群爱偷懒的人，能否在基于socket通信的基础上，进行改进，形成统一的标准、简化操作、更快速的进行业务开发。Web Service就这样产生了。 Web ServiceWebService概念介绍简单一句话使部署在Web服务器上的应用程序，向外界暴露出一个能够过Web方式访问的API，来进行数据的交互，达到异构平台的互通性。所谓的异构平台，是指Java语言开发的应用程序暴露出来的服务能够被C++语言开发的应用程序无障碍的进行数据交互。 WebService的规则 xml:soap消息使用xml进行序列化，该协议通常由http协议承载。 soap：simple object access协议，简单对象访问协议。由http协议承载。需要注意的是Map、泛型类对象无法进行传输。 wsdl：WebService描述语言，它也是xml实现的。服务接口描述。 WebService的四种访问方式soap1.1、soap1.2、http-get、http-post wsimportWebService的推荐访问方式。该方式是对远程的WebService生产本地代理，再通过代理来访问WebService。 使用wsimport命令的要求 jdk版本要在jdk1.6.21及以上 操作系统安装的jdk版本与eclipse默认指定的版本要一致 wsimport的使用12345语法：wsimport [options] &lt;wsdl_uri&gt;-wsdl_uri：wsdl的统一资源标识符-d：指定要输出文件的位置-s：表示要解析Java的源码，默认解析出来的是class字节码文件-p：指定输出的包名 Java对于webservice的支持JAX-WS：JAX-WS(Java API for XML Web Services)规范是一组XML web services的JAVA API，JAX-WS允许开发者可以选择RPC-oriented或者message-oriented 来实现自己的web services。 以注解的方式自定义发布WebService服务 在需要对外提供服务的业务类上声明注解@WebService 通过Endpoint类的静态方法发布一个WebService服务Endpoint.publish(address, implementor);address：发布的服务地址implementor：服务的实现对象第一次解析出错，是因为我本地设置了代理服务器IP。取消代理即可解析成功。 生成jar包，使用jar -cvf jar包名.jar 清单文件所在的文件名该命令会把生成的jar包直接放在控制台的路径中，如需要更改导出路径，需要进入指定路径，再执行jar命令。 测试一下所发布的服务 WDSL文件介绍该文件的阅读是从下往上看。123456789service name：服务名tns:是targetNameSpace的缩写，tns都能找到详细定义port name：服务的访问方式binding name：绑定名type：对外提供WebService业务类的类名或者接口名transport：传输方式，访问方式operation name：对外提供WebService的方法名input message：输入参数output message：输出参数 常用注解说明12345678910@WebService：使用该注解发布服务时，默认是只对public修饰的方法进行发布。serviceName：更改发布的服务名targetNamespace：更改目标命名空间@WebMethod：修饰方法的注解operationName：更改访问方法名exclude：是否排除发布@WebResult：修饰方法的返回值name：更改显示返回值的名称@WebParam：修饰方法的参数name：更改显示参数的名称 发布具有WebService服务的接口流程： 在接口类中声明@WebService注解。 在接口类的实现类中也必须声明@WebService注解，并设置服务端点接口，指定对外提供服务的接口。endpointInterface=”接口类的全路径”。 对服务方法发布有所更改的，在接口类中进行注解配置。 通过CXF框架发布WebService ServerFactoryBean发布服务：使用该类不设置注解也可以发布WebService服务，不支持注解，不支持拦截器的添加。 JaxWsServerFactoryBean发布服务：该类支持注解，可以添加拦截器。 WebService访问流程：通过CXF发布的服务 检测本地代理描述的WSDL是否与服务端的WSDL一致，俗称握手。 通过soap协议实现通信，采用post请求，数据封装在满足soap规约的xml中。 返回数据同样采用soap通信，数据封装在满足soap规约的xml中。CXF与Spring框架整合发布WebService web.xml的文件配置。由CXFServlet处理（项目名/ws/*）的访问请求。 spring的applicationContext.xml文件配置。 服务接口 查看发布的服务说明 发布成功，即可按照wsimport命令生成本地服务代理，在本地项目中访问远程服务 RPC框架原理RPC，它是一种进程间的通信方式。允许像调用本地服务一样调用远程服务。这里说明一下进程间的通信方式，在我们熟知的操作系统中（Windows、Linux），一个进程想要直接跟另一个进程进行数据交互，是禁止的，安全壁垒。但是在Android系统中，它提供了另外一种方式JNI，这是笔者目前所认知到唯一一种操作系统，提供跨进程通信的方式。这里不在细谈。回到主题，RPC框架的目标是让远程服务调用更加简单、透明。跟WebService一样，屏蔽底层的操作细节。 核心技术点 服务调用相关信息，相当于API说明。类似于WebService的WSDL文件，描述所发布的服务。 远程代理对象。服务调用者调用的服务实际是远程服务的本地代理。 RPC框架通信与具体的协议无关。 远程通信需要将数据对象转换成二进制码流进行网络传输，就需要进行序列化。序列化框架的选择。 简单的RPC框架实现基于Java原生的序列化接口、socket通信、动态代理、反射机制，来实现一个最简单的RPC框架。 RPC服务端代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package rpc.exporter;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Method;import java.net.InetSocketAddress;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.Executor;import java.util.concurrent.Executors;/** * @Company * @author dhs * @date 2017年1月31日 下午7:58:27 * @version 1.0 * @description 服务端提供者 */public class RpcExporter &#123; // 获取固定的线程池 static Executor executor = Executors.newFixedThreadPool(Runtime .getRuntime().availableProcessors()); public static void exporter(String hostName, int port) throws Exception &#123; ServerSocket server = new ServerSocket(); server.bind(new InetSocketAddress(hostName, port)); try &#123; while (true) &#123; executor.execute(new ExecutorTask(server.accept())); &#125; &#125; finally &#123; server.close(); &#125; &#125; // 实现子线程的内部类，用于接收指定主机与端口的服务处理。 private static class ExecutorTask implements Runnable &#123; Socket client = null; public ExecutorTask(Socket client) &#123; this.client = client; &#125; @Override public void run() &#123; ObjectInputStream input = null; ObjectOutputStream output = null; try &#123; // 从远处客户端的socket中获取对象输入流 input = new ObjectInputStream(client.getInputStream()); // 获取接口类名 String interfaceName = input.readUTF(); Class&lt;?&gt; service = Class.forName(interfaceName); System.out.println(interfaceName); // 获取接口方法名 String methodName = input.readUTF(); System.out.println(methodName); // 获取接口方法的参数类型 Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) input.readObject(); // 获取接口方法的参数值 Object[] arguments = (Object[]) input.readObject(); // 反射出需要执行的方法 Method method = service.getMethod(methodName, parameterTypes); // 执行该方法并获取结果 Object result = method.invoke(service.newInstance(), arguments); output = new ObjectOutputStream(client.getOutputStream()); output.writeObject(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //关流 if (input != null) &#123; try &#123; input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (output != null) &#123; try &#123; output.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (client != null) &#123; try &#123; client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 123456789101112package rpc.service;/** * @Company * @author dhs * @date 2017年1月31日 下午7:50:01 * @version 1.0 * @description 服务提供者的接口 */public interface EchoService &#123; public String echo(String ping);&#125; 12345678910111213141516171819package rpc.service.impl;import rpc.service.EchoService;/** * @Company * @author dhs * @date 2017年1月31日 下午6:59:51 * @version 1.0 * @description 服务提供者的接口实现类 */public class EchoServiceImpl implements EchoService &#123; @Override public String echo(String ping) &#123; return ping != null ? ping + "---&gt;I am OK":"I am OK"; &#125; &#125; 12345678910111213141516171819202122232425262728package rpc;import rpc.exporter.RpcExporter;/** * @Company * @author dhs * @date 2017年1月31日 下午10:00:06 * @version 1.0 * @description 服务端 */public class RpcTest &#123; public static void main(String[] args) &#123; //子线程启动服务端 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; RpcExporter.exporter("localhost", 8088); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125;&#125; RPC客户端代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package rpc.importer;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.net.InetSocketAddress;import java.net.Socket;/** * @Company * @author dhs * @date 2017年1月31日 下午9:41:13 * @version 1.0 * @description RPC客户端 */public class RpcImporter&lt;T&gt; &#123; @SuppressWarnings("unchecked") public T importer(final Class&lt;?&gt; serviceClass, final InetSocketAddress addr) &#123; //采用JDK的动态代理返回代理对象。参数一：类加载器。参数二：基于接口产生代理对象。参数三：执行方法。 return (T) Proxy.newProxyInstance(serviceClass.getClassLoader(), new Class&lt;?&gt;[] &#123; serviceClass.getInterfaces()[0] &#125;, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Socket socket = null; ObjectInputStream input = null; ObjectOutputStream output = null; try &#123; socket = new Socket(); //远程连接通信 socket.connect(addr); output = new ObjectOutputStream(socket .getOutputStream()); output.writeUTF(serviceClass.getName()); output.writeUTF(method.getName()); output.writeObject(method.getParameterTypes()); output.writeObject(args); input = new ObjectInputStream(socket .getInputStream()); return input.readObject(); &#125; finally &#123; if (socket != null) &#123; socket.close(); &#125; if (input != null) &#123; input.close(); &#125; if (output != null) &#123; output.close(); &#125; &#125; &#125; &#125;); &#125;&#125; 123456789101112131415161718192021222324package rpc.test;import java.net.InetSocketAddress;import rpc.importer.RpcImporter;import rpc.service.EchoService;import rpc.service.impl.EchoServiceImpl;/** * @Company * @author dhs * @date 2017年1月31日 下午10:10:06 * @version 1.0 * @description 客户端 */public class RpcTest &#123; public static void main(String[] args) &#123; RpcImporter&lt;EchoService&gt; importer = new RpcImporter&lt;EchoService&gt;(); EchoService echoService = importer.importer(EchoServiceImpl.class, new InetSocketAddress("localhost", 8088)); System.out.println(echoService.echo("Are you OK?")); &#125;&#125; 测试通信 需要在客户端项目，导入服务端生成的jar包。 启动服务端项目。 客户端与服务端通信。 微服务中消费者远程服务调用流程]]></content>
      <categories>
        <category>随笔</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[云栖大会广东分会感想]]></title>
    <url>%2F2017%2F11%2F23%2Fthoughts%2F</url>
    <content type="text"><![CDATA[有幸参加了2017年云栖大会广东分会，其实刚开始都没怎么有太多的期望。但还是抱着反正也报名成功了，不如来聆听一次。收获很大，而这种收获不仅仅只是技术知识的收获，而是思想上的收获。 一位科学家闵万里，阿里云人工智能首席科学家。科学家！以前觉得好遥远，也不知道科学家到达是啥模样。是不是像小时候老师说的，科学家都很古板、很安静，只会一脑子的做实验。今天听这个科学家讲完，感觉被老师给误导了。分享了他关于ET城市大脑的理解与实践。从他的演讲谈吐中，瞬间有一种如沐春风感。有条不紊，思路逻辑处处缜密，而又不缺引人入深的思考。从两千年前阿基米德的名言，引入消失的城市（亚特兰蒂斯、楼兰古城），塞纳河上的第一艘蒸汽船。足可见闵博士的阅读之多、思考之深。瞬间颠覆了我心中对于科学家的定义。甚至让我有点浮想联翩，人生就需要与高段位的选手做队友。在闵博士分享关于城市这个命题的研究与实践时，又不得不佩服此科学家对于真理的追求，与心中的那份笃定。博士在分享时，是快乐的、开心的。不禁思考起，初中时老师常说的一句话：“吃得苦中苦方为人上人。”直到今天，心中才终于有了答案。老师在说那句话的场景，本意是想要我能吃下读书的苦。但是当我听完那句话之后，一直把疑惑埋在心底。如果读书真的那么苦，那我还要苦这么多年，读书的意义又是何在？回想踏入社会后的学习，感慨自身知识的匮乏，才真正明白。博士的快乐，正式这份求知。用笃定、探索去解心中之惑。而我，从小就认为自己并不比别人差。而青春年少时，未种下梦想的种子。以及读书是一件苦差事的灌输，成长到了目前的人生轨迹。所幸，今天聆听闵博士一席话解了前半生的惑。幸哉幸哉。 一次颁奖典礼天池大数据竞赛的颁奖典礼。这个心目中关注已久的顶级大赛，我总算是瞧见了一次颁奖典礼。能够参加的肯定都是高手，能够获胜的肯定都是顶级高手。这种顶级大赛的竞争，不正燃烧了我心中的向往吗？所以，为了内心的向往，每天每夜的学习都是一件快乐的事情。这样我才能离它更近。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单例设计模式]]></title>
    <url>%2F2017%2F11%2F12%2Fsingle-design%2F</url>
    <content type="text"><![CDATA[Java中有23种设计模式。设计模式是针对问题最有效的解决方法。单例设计模式：解决一个类在内存中只存在一个实例。其应用场景如下： 在多线程之间，只初始化一次的资源。如socket资源、servlet环境等。 在整个程序空间使用全局变量，共享资源。 节省对象的创建时间等等。 实现步骤 禁止其他的应用程序，通过此类来创建对象。私有化构造函数。 在本类里面创建对象。 为了其他应用程序能够访问本类对象，需要对外界提供一种访问方式。 饿汉式1234567891011class Single &#123; private static Single s = new Single(); private Single() &#123; &#125; public static Single getInstance() &#123; return s; &#125;&#125; 静态成员，随着类的加载而被加载。该类在加载进内存时候，就已经初始化一个对象。俗称：饿汉式。通过getInstance()即可获取该对象，并使用该对象。 懒汉式123456789101112131415161718class Single &#123; private static Single s = null; private Single() &#123; &#125; public static Single getInstance() &#123; if (s == null) &#123; synchronized (Single.class) &#123; if (s == null) &#123; s = new Single(); &#125; &#125; &#125; return s; &#125;&#125; 静态成员，随着类的加载而被加载。该类在加载进内存时候，对象还不存在。通过getInstance()获取该对象的时候才会初始化。那么这时就会出现线程安全问题。这里需要明确一点：线程安全问题：只读不写没有该问题，有读有写就有该问题。这也是饿汉式为什么没有线程安全问题的原因。 synchronized代码块使用的锁，是该类的字节码对象锁。getInstance()在任何地方调用，都会发生互斥。getInstance()方法用了两个if判断，为什么不直接使用下面的代码呢？123456public static Single getInstance() &#123; synchronized (Single.class) &#123; s = new Single(); &#125; return s;&#125; 多线程中每一个线程调用getInstance()都会发生互斥。 当有第一个线程进入到同步代码块创建一个对象的时候，刚走到return，互斥已经结束。第二个线程进入到同步代码块，这时又会创建一个对象。在内存中就会出现两个对象。结论加双重if，同步效率较高一点。Java中的示例Runtime类，饿汉式System类，懒汉式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis的总结与回顾]]></title>
    <url>%2F2017%2F10%2F12%2Fredis-summary%2F</url>
    <content type="text"><![CDATA[关系型数据库（Mysql、Oracle）优点 数据之间有关系，进行数据的操作时非常方便。 有事务操作，保证了数据的完整性。 缺点 因为数据和数据之间有关系的，而这种关系是由底层大量算法所保证。 数据的存储与使用，访问量大时IO的资源消耗较大。 大量算法会拉低系统的运行速度，并且会消耗系统资源。 在海量数据的增删改查时会显得无能为力，很可能会宕机。 在海量数据环境下对数据表进行维护、扩展，也会变得无能为力 例如： update product set cname = ‘手机数码’;//修改所有数据 把商品表的cname字段，由varchar(64),char(100);//更改表字段属性非关系型数据库（NoSQL）No不是单词no，是not only的缩写。设计之初是为了替代关系型数据库。足见其野心。优点 海量数据的增删改查，非常轻松 海量数据的维护非常轻松 缺点 数据与数据之间没有关系，所以不能一目了然 没有强大的事务，保证数据的完整和安全 redis概述key-value结构的数据，类似Java中的Map，默认占用6379端口。共有5钟数据类型。string、hash、list、set、有序的set集合。 redis在Linux中的安装redis是C语言开发，编译依赖gcc环境，需检查Linux环境是否有安装gcc如果提示”bash: gcc: command not found”，则需要安装gcc环境。命令：yum install gcc-c++如果提示是否下载，输入y。如果提示是否安装，输入y。 把redis的压缩文件上传至Linux服务器，解压的文件目录并进行编译 执行安装 拷贝配置文件至安装目录中redis启动需要一个配置文件，可以修改端口号等配置。如果没有配置文件redis也可以启动，启用的是默认配置，不方修改端口号等配置。 bin文件夹下的文件 redis-benchmark —-性能测试工具 redis-check-aof —-AOF文件修复工具 redis-check-dump —-RDB文件检查工具（快照持久化文件） redis-cli —-命令行客户端 redis-server —-redis服务器启动命令 前端启动服务该启动方式有硬伤：无法进行集群部署 连接redis可以在上图的命令中加入参数 -h ip地址 -p 端口进行指定连接 后端启动服务修改redis.conf配置文件的daemonize为yes即可如果无法启动修改配置supervised yes为supervised no。按上图进行后端启动。 redis的5种数据类型 String 字符串类型是redis中最为基础、常用的数据存储类型，它在redis中是二进制安全的，value最多可以容纳的数据长度是512M。 二进制安全和数据安全是没有关系的。 关系型数据库，二进制是不安全的。会出现乱码丢失数据。编解码频繁。 以MySQL为例，它能指定数据的存储的字符集。服务器在拿到表中的数据时，很可能因为解码的码表不一致，导致出现数据的乱码。 redis直接存储的二进制数据，不会对数据再进行编解码操作。常用的命令12345678set key value：赋值、修改操作，key相同则覆盖，新值覆盖旧值。del key：删除成功返回1（integer），key不存在返回0（integer）getset key value：先取后赋值incr key：递增1，非数字则报错decr key：递减1，非数字则报错append key value：类似StringBuffer的appendincrby key number：递增指定的数值decrby key number：递减指定的数值 hashhash类型可以看成是具有String key和String value的map容器。非常适合于存储值对象的信息。占用的磁盘空间极少。其表现形式是{uname:”zhangsna”,age:”19”,sex:”man”} 常用的命令1234567hset key field value：赋值操作，为key的某个字段赋值。hset key field value [field2 value2 ...]：为key的多个字段进行赋值。hmget key field1 field2 ...：获取key中多个field的值hgetall key：获取key中所有的filed-valuedel key：删除整个hashhkeys key：获取key所有的filedhvals key：获取key所有的value list链表结构，redis的操作中，最多的操作就是进行元素的增删，它的使用环境是做大数据集合的增删、任务队列。关于链表结构，可查看《Java的List、Set、Map容器》一文 常用的命令1234567lpush key value [value2 ...]：赋值，从左侧开始添加（每次添加都是从左侧开始）rpush key value [value2 ...]：赋值，从右侧开始添加（每次添加都是从右侧开始）lrange key start end：获取key链表中从start到end的元素值（含头又含尾）。start为0，end为-1时，表示取整个链表的元素值。lpop key：从左侧开始删除rpop key：从右侧开始删除llen key：返回指定的key关联的链表中元素数量rpoplpush source destination：将链表中的尾部元素弹出并添加到头部（循环） set在redis中，可以将set类型看作为没有排序的字符集合。set可包含的最大元素数量是4294967295。set集合中不允许出现重复的元素，可在服务端完成多个set之间的聚合计算操作。效率极高。 常用的命令1234567891011sadd key value [value2 ...]：赋值smembers key：获取set集合key中所有的成员sismember key member：判断参数中指定的成员是否在该set中，返回1表示存在、0表示不存在srem key member [member2 ...]：删除set中指定的成员sdiff key1 key2 ...：返回key1与key2中相差的成员，而且与key的顺序有关。返回差集sinter key1 key2 ...：返回交集sunion key1 key2 ...：返回并集scard key：获取set集合key中成员的数量srandmember key：随机返回set中的一个成员sdiffstore destination key1 key2 ...：将返回的差集成员存储在destination上sunionstore destination key1 key2 ...：将返回的差集成员存储在destination上 有序set有序，不重复。在集合元素上分配分数，每个元素都需要手动赋予一个分数。 常用的命令12345678910zadd key score member score2 member ...：赋值zscore key member：返回指定成员的分数zrange key start end [withscores]：获取集合中角标为start-end的成员，分数由小到大zrevrange key start end [withscores]：获取集合中角标为start-end的成员，分数由大到小zrem key member [member2 ...]：移除集合中指定的成员zremrangebyrank key start stop：按照排名范围删除元素zremrangebyscore key min max：按照分数范围删除元素zcount key min max：获取分数在min-max之间的成员zrank key member：返回成员在集合中排名，索引从小到大zrevrank key member：返回成员在集合中的排序，索引从大到小 通用命令1234567891011keys *：*号表示0个或多个任意字符keys ?：?号表示1个字符（任意）del key1 key2 ...：删除对应的keyexists key：判断key是否存在，1表示存在，0表示不存在rename key newkey：为key重命名type key：获取指定key的值类型expire key：设置key的生存时间ttl key：查看key所剩的超时时间。如果没有设置超时，返回-1。如果返回-2，表示超时不存在。quit：退出客户端dbsize：返回当前数据库中key的数目info：查看redis的信息 消息订阅与发布subscribe channel：订阅频道psubscribe channel*：批量订阅频道，*是通配符，订阅以channel部分的值为开头的频道publish channel content：在指定的频道中发布消息 多数据库redis默认有16个数据库，名称从0、1、2…15。在redis上所做的所有数据操作，默认在0号数据库上操作的。命令config get databases可查看数据的个数。数据库和数据库之间，是不能共享键值对。命令select 数据库名，切换数据库。move key dbname：将当前库的key移植到指定的数据库中。flushdb，清空当前数据库。flushall，清空redis服务器的数据。 事务关系型数据库的事务，是为了保证数据的完整性、保证数据安全。可查看《关系型数据库的事务》一文。redis的事务，是为了进行redis语句的批量执行。multi：开启事务，用于标记事务的开始，其后执行的命令都将被存入命令队列。exec：提交事务，执行批量化操作discard：事务回滚，不执行批量化操作 redis的两种持久化策略RDBredis默认的持久化机制。安装目录下的dump.rdb文件。相当于照快照，保存的是一种状态。优点：快照保存速度极快，还原数据速度极快。适用灾难备份。缺点：小内存机器不适合使用。RDB机制，符合要求就会照快照（随时随地启动），会占用一部分系统资源（突然的），很可能内存不足直接宕机。适用于内存服务器正常关闭时，照快照。./bin/redis-cli shutdownkey满足一定条件，照快照。 redis.conf的配置，第二列是时间（秒），第三列是发生变化的key的个数。达到，则会在时间到达后照快照。 AOF使用日志功能保存数据操作。默认AOF机制是关闭的。AOF操作，只会保存导致对应key发生变化的语句（增、删。改），保存的是语句不是数据。一个key在操作中可能出现10次的变化，如key保存的value变了，日志就会有对应的每次发生变化的语句。优点：持续占用极少量的内存资源。缺点：日志文件会特别大，不适用于灾难恢复。数据恢复效率远远低于RDB，适用于内存较小的计算机。 1234redis.conf文件中把appendonly no修改为appendonly yes，开启AOF机制appendfsync always --每修改同步，只要有key变化语句，就进行AOF保存数据。比较安全，浪费效率appendfsync everysec --每秒进行一次AOF保存数据。安全性低，节省系统资源（默认机制）appendfsync no --不同步，不进行任何持久化操作。不安全 Java中访问redis导包 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445package redis;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * @description * @version 1.0,2017年8月19日 下午6:11:25,Denghs * @remark */public class TestJedisConnection &#123; public static void main(String[] args) &#123; poolConnection(); &#125; /** * 单实例连接redis数据库 */ public static void instanceConnection()&#123; Jedis jedis = new Jedis("192.168.17.128", 6379); //jedis.set("name", "王五"); System.out.println(jedis.get("name")); &#125; /** * 池连接技术 */ public static void poolConnection()&#123; //连接池配置 JedisPoolConfig config = new JedisPoolConfig(); //最大连接总数 config.setMaxTotal(50); //最大闲置连接数 config.setMaxIdle(10); //Jedis连接池 JedisPool jedisPool = new JedisPool(config, "192.168.17.128", 6379); //获取连接资源 Jedis jedis = jedisPool.getResource(); System.out.println(jedis.get("name")); //释放资源 jedis.close(); &#125;&#125;]]></content>
      <categories>
        <category>NOSQL</category>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[表单修改的操作记录 OperateLog]]></title>
    <url>%2F2017%2F08%2F21%2Foperate-log%2F</url>
    <content type="text"><![CDATA[在表单回显数据时，点击修改。记录住被修改的字段，旧值与新值。 实现思路 采用反射+注解。写了一个工具类。当前端把表单数据从前台带入到后台后。把request对象跟原始记录对象传入进行比较。 工具类中的方法采用反射，获取原始对象上的字段的值。再跟request中的请求参数值进行比较。在原始对象类中，使用注解，对需要进行比较的字段，加入注解，并设置字段中文名。 工具类中的比较只能对基本数据类型、基本数据类型的包装类型、Date类型进行比较。数组、集合、关联对象是不会进行比较的。这是欠缺的地方，欢迎补充。 示例图点击查询：（模拟项目中查询数据） 回显数据：（模拟项目中表单回显数据） 修改数据：（模拟项目中表单修改数据）修改了4项，点击修改，提交到后台 修改数据的操作记录 再来一次 显示操作记录 代码示例图在属性上加入注解，指定属性的中文名。工具类中的代码，可以参照这套思路去扩展。 总结 代码已放到仓库中。https://github.com/denghuashan/OperateLog 欢迎指正或进行扩展。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于Java中泛型的认知与理解]]></title>
    <url>%2F2017%2F08%2F17%2Fabout-generics%2F</url>
    <content type="text"><![CDATA[近期看了《深入理解Java虚拟机》中对语法糖、泛型（称伪泛型）的一些介绍，顺便总结梳理一下以前对JDK1.5引入的泛型的理解与使用。 为何会引入泛型12345678910111213141516171819public class Tools&#123; private Object obj; public Object getObj() &#123; return obj; &#125; public void setObj(Object obj) &#123; this.obj = obj; &#125; public static void main(String[] args) &#123; Tools tools = new Tools(); tools.setObj("这是Object"); Object obj2 = tools.getObj(); Integer i = (Integer) obj2; System.out.println(i); &#125;&#125; 上面这段代码，稍微有点经验，都知道会抛异常java.lang.ClassCastException。但是抛异常的时机却是在运行期。JVM在编译这段代码时，是可以通过的。tools.getObj()获取到对象时，需要程序员手动进行类型转换。这是早期关于Object做法。所以，泛型有了它的用武之地。 泛型类12345678910111213141516171819202122232425public class Utils&lt;T&gt; &#123; private T t; public void setObject(T t) &#123; this.t = t; &#125; public T getObject() &#123; return t; &#125; public static void main(String[] args) &#123; Utils&lt;Singer&gt; utils1 = new Utils&lt;Singer&gt;(); utils1.setObject(new Singer()); Singer s = utils1.getObject(); &#125;&#125;class Singer &#123; &#125;class Worker &#123;&#125; utils1.getObject()时不用进行类型强转。因为它的类型是在new Utils()时就已经确定了。直接在编译期就进行了安全提示。 泛型方法123456789101112public class Demo &#123; // 泛型方法 public &lt;T&gt; void show(T t) &#123; System.out.println("show:::" + t); &#125; public static void main(String[] args) &#123; Demo demo = new Demo(); demo.show("haha"); demo.show(new Tools()); &#125;&#125; 泛型方法，它的类型是调用方法时，由实参决定的。 泛型类，泛型方法12345678910111213141516171819202122232425public class Demo&lt;T&gt; &#123; // 该方法跟着定义的泛型类走，固定类型 public void show(T t) &#123; System.out.println("show---&gt;" + t); &#125; // 泛型方法 public &lt;W&gt; void print(W w) &#123; System.out.println("print---&gt;" + w); &#125; // 静态泛型方法 public static &lt;Q&gt; void say(Q q) &#123; System.out.println("say---&gt;" + q); &#125; public static void main(String[] args) &#123; Demo&lt;String&gt; demo = new Demo&lt;String&gt;(); demo.show("haha1"); demo.print(2008); demo.print("haha2"); Demo.say(3.1415926); Demo.say("haha3"); &#125;&#125; 实际运行结果如下：show()方法的类型是跟着Demo上面定义的T走的，所以可以隐藏该方法的泛型。print()方法的类型是由实参决定的。say()方法的类型也是由实参决定的。 关于泛型的总结 用于解决安全问题，是一个安全机制。类型安全机制。 将运行时期出现的问题java.lang.ClassCastException转移到了编译期。 避免强制类型转换的麻烦。 泛型的类型必须为引用类型，不能是基本类型。 什么时候定义泛型 当类中要操作的引用数据类型不确定的时候，早期定义Object来完成扩展，现在定义泛型来完成扩展。 泛型类定义的泛型，在整个类中有效。如果该泛型被方法使用，那么泛型类的对象在明确要操作的具体类型后，该方法要操作的数据类型就已经固定了。 为了让不同的方法可以操作不同类型，而且类型不确定。那么可以将泛型定义在方法上。 静态方法是不可以访问类上定义的泛型。如果静态方法操作的数据类型不确定，可以将泛型定义在该方法上。 泛型类每次都是在建立对象时才会被明确，由对象带着类型去运行。 实际使用场景一123456789101112131415161718public class WebUtils &#123; //把request中的数据封装到bean中 public static &lt;T&gt; T request2Bean(HttpServletRequest request,Class&lt;T&gt; clazz)&#123; try&#123; T t = clazz.newInstance(); Enumeration e = request.getParameterNames(); while(e.hasMoreElements())&#123; String name= (String) e.nextElement(); String value = request.getParameter(name); BeanUtils.setProperty(t, name, value); &#125; return t; &#125;catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 使用静态泛型方法把request中的请求参数，通过反射+BeanUtils，直接封装成对象并返回。 实际使用场景二123456789101112131415161718public class DaoFactory &#123; private DaoFactory()&#123;&#125; private static final DaoFactory instance = new DaoFactory(); public static DaoFactory getInstance()&#123; return instance; &#125; public &lt;T&gt; T createDao(String className,Class&lt;T&gt; clazz)&#123; try &#123; return (T) Class.forName(className).newInstance(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; 使用工厂设计模式+泛型方法。 实际使用场景三1234567891011121314class BaseDao&lt;T&gt; &#123; // 把最共性的方法，抽取到该基类中来 public List&lt;T&gt; findAll() &#123; System.out.println("findAll---&gt;"); return new ArrayList&lt;T&gt;(); &#125;&#125;public class DemoDao extends BaseDao&lt;Demo&gt; &#123; public static void main(String[] args) &#123; DemoDao demoDao = new DemoDao(); System.out.println(demoDao.findAll()); &#125;&#125; 在new DemoDao的时候，DemoDao继承基类中的findAll()方法就明确是操作Demo这种类型的数据了。 泛型中的通配符与限定（用于泛型扩展） ?通配符，可以理解为占位符。?表示不确定类型。T表示为具体类型，传什么就是什么类型。 ? extends E：表示可以接收E类型或者E类型的子类型。称为泛型的上限。 ? super E：表示可以接收E类型或者E类型的父类型。称为泛型的下限。]]></content>
      <categories>
        <category>泛型</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[应用的变迁]]></title>
    <url>%2F2017%2F08%2F12%2Fevolution%2F</url>
    <content type="text"><![CDATA[时代在变迁，技术在变革，我们所处的环境也一直在发生着变化。浅谈一下对应用变迁的一种自我认知，尝试去理解这种变迁背后深层次的原因。 传统垂直架构还清晰的记得第一次搭建tomcat，第一次做web服务。从jsp、servlet、JDBC实现编写的第一个完整的web应用。MVC三层架构的理解与实践。至Strust2、Spring、SptringMVC、Hibernate、mybatis的学习、理解、应用。更多的出发点，也仅仅只是想要掌握这些技术。这就是一个典型的垂直架构应用。本地应用间的API调用。 特点： 技术比较单一（如SSH、SSM技术的集成） 学习成本低（会用才是重点、无需了解其原理） 开发上手较快（一个基本的DEMO，就能对着业务进行开发） 测试、部署、运维比较简单（LAMP） 整个应用模块都部署在同一个进程内，一旦发生故障，整个节点宕机。 面向服务的架构随着越来越多的垂直架构，异构系统之间的通信与数据交换成为需求。以RPC框架为基础，各种面向服务的框架开始流行。如Dubbo+Zookeeper等技术。RPC本身只是一种进程间的通信方式，允许像调用本地服务一样调用远程服务。个人觉得比较原始一点的面向服务的架构，应该是基于WebService搭建的ESB（企业服务总线）。其三要素完整的表述了一个服务，UDDI目录、WSDL说明书、SOAP协议。实现跨平台，跨语言的服务。当然还有RESTful。 微服务架构目前能够理解的，也就是其原子服务，专注于做一件事，“高内聚、松耦合”。功能越单一，也就意味着对其他的功能依赖越少。其他的高密度部署、敏捷交付、微自治，暂时没体验过。 总结了解历史的演进过程，才能清楚自己所处哪个潮流中。该如何在这个技术迭代的浪潮中该如何去选择学习的重点技术。而不是人云亦云的去追逐。个人感觉，跟计算机网络的发展有点类似。从单台计算机到局域网，局域网到广域网。从局域网的CSMA/CD协议，到广域网的点对点协议（PPP协议）。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关系型数据库的事务]]></title>
    <url>%2F2017%2F07%2F31%2Fdatabase-transaction%2F</url>
    <content type="text"><![CDATA[事务是指逻辑上的一组操作，组成这组操作的各个单元要么全部成功，要么全部失败。事务所起的作用就是把多条SQL语句作为一个整体来执行。 事务的四大特性（ACID） 原子性 Atomicty：事务是一个不可分割的单元，要么全部成功，要么全部失败。 一致性 Consistency：事务必须使数据库从一个一致性状态变换到另一个一致性状态。例：转账，前后总额要一致。 隔离性 Isolation：并发访问数据库时，每一个开启的事务，不能被其他事务的操作数据所干扰。并发事务之间要隔离。 持久性 Durability：一个事务一旦被提交，它对数据库中数据的改变就是持久性的。 MySQL数据库对事务的支持 start transaction；—-开启事务 sql语句；—-操作 commit;—-提交事务 rollback；—-回滚事务，可手动回滚事务。 数据库回滚：回滚到事务开始之前位置、状态。 模拟一个异常回滚示例因Oracle数据库对事务的支持与MySQL是有所差异化的。这里以MySQL为例来说明一下事务。start transaction是MySQL中事务的开启。Oracle的事务开启是由第一条DML操作开启的。以一个简单的转账为例。第一个红箭头，开启事务。第二个红箭头，模拟aaa账户减100。没有执行commit操作，假设程序出异常了。关掉这个窗口，重新进入查看。update语句并没有真正改变数据。 模拟一个正常执行示例第一个红箭头，开启事务。中间执行了两个update操作。最后commit，提交该事务。才会永久的保存在数据库中。没有收到commit，数据库则自动回滚了。 事务四大特性中的隔离性Isolation如果不考虑隔离性，可能会引发如下问题： 脏读：一个事务读取了另外一个事务未提交的数据。 不可重复读：在一个事务内，读取表中的某一行数据，多此读取的结果不同。（读取同一条记录，第一次读跟第二次读结果不一样） 虚读（幻读）：在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。（读取同一个表）不可重复读有些情况是正确的，有些情况是不正确的。数据库定义的四种隔离级别 Serializable：可避免脏读、不可重复读、虚读的情况发生。（类似互斥） Repeatable read：可避免脏读、不可重复读的情况发生。MySQL数据库默认的隔离级别。 Read committed：可避免脏读情况发生。Oracle数据库默认的隔离级别 Read uncommitted：最低级别，以上情况均无法保证。 隔离级别越高，性能越差。数据库设置隔离级别：set transaction isolation level ‘隔离级别等级字段’;查询当前事务的隔离级别：select @@tx_isolation;这里就不挨个去做实验了。可以自行设置不同的隔离级，开两个控制台去做实验。Oracle数据库支持Read committed、Serializable两种事务隔离级别。 编程式事务与声明式事务 编程式事务：事务的开启与提交，由程序员在代码中控制。传统的JDBC开启事务、回滚事务、提交事务的操作。编写程序式的事务管理可以清楚的定义事务的边界，可以实现细粒度的事务控制， 声明式事务：事务的开启与提交，不由程序员控制，交由外部容器处理。spring对事务的支持，在配置文件中声明或采用注解即可。解除了事务和代码之间的耦合。本地事务与全局事务 本地事务：在单个EIS或数据库的本地，并且限制在单个进程内的事务。本地事务不涉及多个数据来源。 全局事务：资源管理器和协调的事务，可以跨越多个数据库和进程。采用二阶段提交协议保证事务的成功。 分布式事务 分布式事务基于二阶段提交实现，二次提交协议。二阶段提交采用的是悲观锁策略，由于各个事务参与者需要等待响应最慢的参与者，因此性能比较差。在实际业务使用过程中，使用数据最终一致性替代传统的数据强一致性。使用带有事务功能的MQ做中间人角色。 二阶段提交 准备阶段：又称投票阶段。协调者询问所有参与者是否准备好提交，准备好恢复prepared，否则恢复non-prepared 提交阶段：又称执行阶段。协调者如果在上一阶段收到参与者回复的prepared，则此阶段向所有参与者发送commit指令，否则发送rollback指令。 数据一致模型（简单的说三种） Weak 弱一致性：当你写入一个新值后，读的操作在数据副本上可能会读出来，也可能会读不出来。 Eventually 最终一致性：当你写入一个新值后，有可能读不出来，但在某个时间保证最终能读出来。 Strong 强一致性：新的数据一旦写入，在任意副本时刻都能读到新值。 长事务 一个事务花费很长时间不能够结束，就是一个长的事务，简称长事务。 分布式事务中提到过一点，二阶段提交需要等待响应最慢的参与者。它有可能会变成一个长事务。 Spring中，在业务方法中上声明@Transaction时，如果采用for循环调用dao进行insert、update也可能会造成长事务。 Spring中，在service层的业务方法中上声明@Transaction时，调用另一个service的业务方法，如此去嵌套服务调用，也可能会造成长事务。Spring对于事务的提交，是方法执行完毕。在嵌套调用中，事务的时间由最外层业务方法执行的事务时间。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL的存储引擎]]></title>
    <url>%2F2017%2F07%2F30%2Fmysql-store-engine%2F</url>
    <content type="text"><![CDATA[数据库存储引擎是数据库底层软件组件。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能。MySQL的核心就是存储引擎。 查看MySQL支持的引擎类型在MySQL中，不需要在整个服务器中使用同一种存储引擎，针对具体要求，可以对每一个表使用不同的存储引擎。MySQL5.6支持的存储引擎有：InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE等。可以使用SHOW ENGINES语句查看系统所支持的引擎类型。Support列的值表示某种引擎是否能使用。DEFAULT为默认存储引擎。 InnoDB存储引擎MySQL5.5.5之后，默认的存储引擎。支持事务安全表（ACID），支持行锁定和外键。主要特性有： InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。在SQL查询中，可以将InnoDB类型的表与其他MySQL的表的类型混合起来。 InnoDB是为处理巨大数据量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的。 InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲区。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件。 InnoDB支持外键完整性约束。存储表中的数据时，每张表的存储都是按主键顺序存放，如果没有显示指定主键，InnoDB会为每一行生成一个隐藏的6个字节的ROWID，并以此作为主键。建议InnoDB的主键采用数据库自增策略。后期再补充InnoDB的索引 MyISAM存储引擎MyISAM基于ISAM存储引擎，并对其进行扩展。MyISAM拥有较高的插入、查询速度，但不支持事务。在MySQL5.5.5之前的版本中，MyISAM是默认存储引擎。主要特性有： 大文件（达63位文件长度）在支持大文件的文件系统和操作系统上被支持。 当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块。若下一个块被删除，就扩展下一块来自动完成。 每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16个。 最大的键长度是1000字节，可以通过编译来改变。对键长度超过250字节的情况，一个超过1024字节的键将被用上。 BLOB和TEXT列可以被索引。 NULL值被允许在索引的列中，这个值占每个键的0~1个字节。 所有数字键值以高字节优先被存储，以允许一个更高地索引压缩。 每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE时，该列被更新同时被刷新。 可以把数据文件和索引文件放在不同目录。 每个字符列可以有不同的字符集。 有VARCHAR的表可以固定或动态记录长度。 VARCHAR和CHAR列可以多达64KB。 Memory存储引擎Memory存储引擎将表中的数据，存储到内存中。为查询和引用其他表数据提供快速访问。主要特性有： 每一个表可以有多达32个索引，每个索引16列，以及500字节的最大键长度。 执行哈希（Hash）索引和BTree索引。 在一个Memory表中可以有非唯一键。 使用一个固定的记录长度格式。 不支持BLOB和TEXT列。 支持AUTO_INCREMENT列、可以对包含NULL值的列建立索引。 表内容被存在内存中。 当不在需要表的内容时，要释放被表使用的内存，应该执行DELETE FROM或TRAUNCATE TABLE，或删除整个表（DROP TABLE）。（这里不阐述DELETE、TRAUNCATE、DROP之间的区别） 存储引擎的选择 更改数据表存储引擎查看数据表存储引擎，使用SHOW CREATE TABLE &lt;表名\G&gt;，语句进查看。（“\G”是参数，使结果更加直观，易于查看）更新数据表存储引擎，使用ALTER TABLE &lt;表名&gt; ENGINE=&lt;存储引擎名&gt;; 注意MySQL中外键约束是用来保证数据的参照完整性，如果表之间需要关联外键，却指定了不同的存储引擎，这些表之间是不能创建外键约束的。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[工厂、策略、观察者设计模式]]></title>
    <url>%2F2017%2F07%2F29%2Ffactory-design%2F</url>
    <content type="text"><![CDATA[这里贴一下以前对工厂、策略、观察者设计模式的代码实现。 简单工厂设计模式简单工厂设计模式，并不属于标准的23种设计模式之一。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//此工厂返回service的代理public class ServiceFactory &#123; private static final ServiceFactory instance = new ServiceFactory(); private ServiceFactory() &#123; &#125; public static ServiceFactory getInstance() &#123; return instance; &#125; //返回具体服务的代理对象 public &lt;T&gt; T createService(String className, Class&lt;T&gt; clazz, final User user) &#123; if (null == className || "".equals(className.trim()) || null == clazz) &#123; return null; &#125; try &#123; final T t = (T) Class.forName(className).newInstance(); return (T) Proxy.newProxyInstance(ServiceFactory.class .getClassLoader(), t.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 1.判断用户调用的是什么方法 String methodName = method.getName(); // 2.反射出真实对象上相对应的方法 Method m = t.getClass().getMethod(methodName, method.getParameterTypes()); // 3.看真实对象上相对应的方法是否有权限注解 Permission p = m.getAnnotation(Permission.class); // 4.如果没有,代表访问该方法不需要权限,直接放行 if (p == null) &#123; return method.invoke(t, args); &#125; // 5.如果有,得到该方法需要什么权限, String value = p.value(); Privilege privilege = new Privilege(); privilege.setName(value); // 6.得到用户的权限 if (user == null) &#123; throw new PrivilegeException("对不起,请先登录!"); &#125; BusinessService service = (BusinessService) t; List&lt;Privilege&gt; list = service .getUserPrivilege(user.getId()); // 7.检查用户是否有权限,如果有权限,放行 if (list.contains(privilege)) &#123; return method.invoke(t, args); &#125; // 8.如果没有权限,则抛编译时异常,提示web层给用户一个友好提示 throw new PrivilegeException( "对不起,您没有相对应的访问权限,请联系管理员!"); &#125; &#125;); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; ServiceFactory提供一个创建服务方法。createService()，主要是运用反射产生具体的服务代理对象。代理对象在这里执行方法时，加了一段业务逻辑处理。其实这段代码采用了面向切面的思想（AOP思想），其主要目的实现解耦。获取执行方法上的注解。spring中加在类上的@Service、@Controller、@Component、以及可以加在类上和方法上的@Transactional注解，原理都是类似的。 采用饿汉式的简单工厂模式123456789101112131415161718192021package cn.utils;//泛型工厂public class DaoFactory &#123; private DaoFactory()&#123;&#125; private static final DaoFactory instance = new DaoFactory(); public static DaoFactory getInstance()&#123; return instance; &#125; public &lt;T&gt; T createDao(String className,Class&lt;T&gt; clazz)&#123; try &#123; return (T) Class.forName(className).newInstance(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; 观察者设计模式在说观察者设计模式之前，需要提一个东西。事件监听：Event事件对象封装了事件源及动作。 事件监听机制 事件监听涉及三个组件：事件源，事件对象，事件监听。 当事件源上发生某一个动作时，它会调用事件监听器的一个方法，并在调用该方法时，把事件对象传递进去。 代码实现1234567891011121314151617181920212223242526//观察者设计模式public class ObserverDemo &#123; public static void main(String[] args) &#123; Person p = new Person(); System.out.println("Person对象：" + p); //注册一个监听器 p.registerListen(new PersonListen() &#123; //执行具体事件处理动作 @Override public void doeat(Event e) &#123; Person person = e.getSource(); System.out.println("监听到事件源：" + person + "，调用eat()方法"); &#125; @Override public void dorun(Event e) &#123; System.out.println("监听到事件源：调用eat()方法"); &#125; &#125;); p.eat(); p.run(); &#125;&#125; 123456789101112131415161718192021222324public class Person &#123; //事件监听器 private PersonListen personListen; public void eat()&#123; System.out.println("Person eat()"); if (personListen != null) &#123; System.out.println("触发：personListen doeat()"); personListen.doeat(new Event(this)); &#125; &#125; public void run()&#123; System.out.println("Person run()"); if (personListen != null) &#123; System.out.println("触发：personListen dorun()"); personListen.dorun(new Event(this)); &#125; &#125; public void registerListen(PersonListen personListen)&#123; this.personListen = personListen; &#125;&#125; 12345//事件监听接口public interface PersonListen&#123; public void doeat(Event e); public void dorun(Event e);&#125; 1234567891011121314151617181920//事件对象public class Event&#123; private Person source; public Event() &#123; &#125; public Event(Person source) &#123; this.source = source; &#125; public Person getSource() &#123; return source; &#125; public void setSource(Person source) &#123; this.source = source; &#125;&#125; 运行结果Java中常用的各种监听都是观察者设计模式。 策略设计模式功能并不清楚对结果的处理方式，对结果的处理由调用者进行传入。而只是把对结果的处理方式做成接口，通过接口来约定双方的行为。 代码1234//通过接口约定双方的行为public interface ResultSetHandler &#123; Object handler(ResultSet rs);&#125; 1234567891011121314151617181920212223242526272829303132333435//处理对单一对象的封装public class BeanHandler implements ResultSetHandler &#123; private Class clazz; //用户把Bean传进来 public BeanHandler(Class clazz)&#123; this.clazz = clazz; &#125; @Override public Object handler(ResultSet rs) &#123; try&#123; if(!rs.next())&#123; return null; &#125; Object bean = clazz.newInstance(); //获取结果集的元信息 ResultSetMetaData metadata = rs.getMetaData(); //得到结果集中有几列数据 int ColumnCount = metadata.getColumnCount(); for(int i=0;i&lt;ColumnCount;i++)&#123; //得到每列的列名 String ColumnName = metadata.getColumnName(i+1); //通过列名获取每一列的数据 Object ColumnData = rs.getObject(i+1); //反射出类中与列名对应的属性 Field f = clazz.getDeclaredField(ColumnName); f.setAccessible(true); f.set(bean, ColumnData); &#125; return bean; &#125;catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132//处理对List的封装public class BeanListHandler implements ResultSetHandler &#123; private Class clazz; //用户把Bean传进来 public BeanListHandler(Class clazz)&#123; this.clazz = clazz; &#125; @Override public Object handler(ResultSet rs) &#123; try&#123; List list = new ArrayList(); while(rs.next())&#123; Object bean = clazz.newInstance(); ResultSetMetaData metadata = rs.getMetaData(); int count = metadata.getColumnCount(); for(int i=0;i&lt;count;i++)&#123; String name = metadata.getColumnName(i+1); Object value = rs.getObject(name); Field f = bean.getClass().getDeclaredField(name); f.setAccessible(true); f.set(bean, value); &#125; list.add(bean); &#125; return list.size() &gt; 0 ? list:null; &#125;catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 封装对方法的具体细节处理对查询单一的对象，把具体的处理方式BeanHandler传入。处理对查询一群的对象，把具体的处理方式BeanListHandler传入。上面这段代码是采用JDBC，运用元数据，实现一个简单的OR-Mapping映射类型的DB框架。 Java中的运用 之前有说过TreeSet集合，可以对元素进行排序。但是它本身并不知道，元素该怎么排，而是由调用者，通过实现Comparator接口，把对元素进行排序方式进行传入，TreeSet按照给定的方式进行处理。 mybatis中对于查询的处理，在一级缓存与二级缓存中也是使用策略模式，通过实现ResultHandler接口对查询结果进行处理。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL的性能优化]]></title>
    <url>%2F2017%2F07%2F28%2Fmysql-optimize%2F</url>
    <content type="text"><![CDATA[MySQL的性能优化包括查询速度优化，更新速度优化，MySQL服务器优化等。如果是SQL查询很慢，可以开启MySQL的慢查询日志。通过慢查询日志，可以找出执行时间较长、执行效率较低的语句，然后进行优化。 EXPLAIN分析通过EXPLAIN语句对查询语句进行分析，找出查询语句的执行瓶颈。上一章稍微介绍过EXPLAIN语句，这里再详细阐述一下。基本语法：EXPLAIN SELECT select_options id：SELECT识别符。SELECT的查询序列号。 select_type：SELECT语句的类型。取值说明如下：SIMPLE表示简单查询，不包括连接查询和子查询。 PRIMARY表示主查询，或者是最外层的查询语句。 UNION表示连接查询的第二个或后面的查询语句。 DEPENDENT UNION表示连接查询中的第二个或后面的SELECT语句，取决于外面的查询。 UNION RESULT表示连接查询的结果。 SUBQUERY表示子查询中的第一个SELECT语句。 DERIVED表示导出表的SELECT中的子查询。 table：表示查询的表 type：表示表的连接类型。取值说明如下：（从最佳类型到最差类型排序）system，该表示仅有一行的系统表。 const：数据表最多只有一个匹配行，它将在查询开始时被读取。查询速度很快，因为只读取一次。 12SELECT * FROM tb_name WHERE primary_key=?;SELECT * FROM tb_name WHERE primary_key_part1=? AND primary_key_part2=?; eq_ref：对于每个来自前面的表的行组合，从该表中读取一行。可以用于使用”=”操作符比较带索引的列。12SELECT * FROM ref_tb,other_tb WHERE ref_tb.key_column=other_tb.column;SELECT * FROM ref_tb,other_tb WHERE ref_tb.key_column_part1=other_tb.column AND ref_tb.key_column_part2=?; ref：对于来自前面的表的任意行组合，将从该表中读取所有匹配的行。可以用于使用”=”或”&lt;=&gt;”操作符带索引的列。123SELECT * FROM ref_tb WHERE key_column=expr;SELECT * FROM ref_tb,other_tb WHERE ref_tb.key_column=other_tb.column;SELECT * FROM ref_tb,other_tb WHERE ref_tb.key_column_part1=other_tb.column AND ref_tb.key_column_part2=?; ref_or_null：如同ref，专门搜索包含NULL值的行。1SELECT * FROM ref_tb WHERE key_column=expr OR key_column IS NULL; index_merge：使用了索引合并优化方法。key列中包含了使用的索引清单。unique_subquery：索引查找函数，可以完全替换子查询。可以下面形式的IN子查询1value IN(SELECT primary_key FROM tb WHERE some_expr) index_subquery：可以替换IN子查询，只适合下列形式的子查询中的非唯一索引。1value IN(SELECT key_column FROM tb WHERE some_expr) range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。当使用”=”，”&lt;&gt;”，”&gt;”，”&gt;=”，”&lt;”，”&lt;=”，”IS NULL”，”&lt;=&gt;”，”BETWEEN”，”IN”操作符，用常量比较关键字列时，类型为range。index：只扫描索引树。ALL：对于前面的表的任意行组合，进行完整的全表扫描。 possible_keys：能使用哪个索引在该表中找到行。NULL则没有相关的索引。 key：实际查询时使用到的索引。NULL则没有选择所有。 key_len：索引自动按字节计算的长度。数值越小，表示越快。 ref：使用哪个列或常数与索引一起来查询记录。 rows：在表中进行查询时必须检查的行数。 Extra：处理查询时的详细信息。 设计合理的索引如下图，没有在f_name字段上增加索引。可以分析执行了全表。查询在f_name字段上增加索引的选择性。选择性越高的索引价值越大。建立索引再来分析。 索引未起作用的特殊情况 在使用LIKE关键字的查询语句中，如果匹配字符串的第一个字符为”%”，索引将不会起作用。只有”%”不在第一个位置，索引才会起作用。 使用多列索引，也就是组合索引。遵循最左前缀集合。比如在f_id、f_name、f_price三个字段创建组合索引。那么在查询条件包含f_id、f_name、f_price或f_id、f_name或f_id时会使用到索引。而f_name、f_price条件则索引将不会起作用。 查询语句的查询条件中只有OR关键字，且OR前后的两个条件中的列都是索引时，查询才会使用到索引。 子查询说明子查询虽然可以使查询语句很灵活，但执行效率不高。这是因为MySQL在执行子查询时，会为内层查询语句的查询结果建立一张临时表。然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。建议使用连接查询来替代子查询。连接查询不需要建立临时表。SELECT语句中避免使用*号通配符。数据库在解析的过程中，会将*号依次转换成所有的列名，这个工作是通过查询数据字典完成的。意味着耗费更多的时间。 数据库的结构优化对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新的表。 范式 范式是为解决数据的存储与优化。保存数据的存储后，凡是能够通过关系寻找出来的数据，坚决不再重复存储，终极目标是为了减少数据的冗余。范式是一种分层结构的规范，分为六层。每一层都比上一层更加严格，若要满足下一层范式，前提是满足上一层范式。 六层范式：1NF、2NF、3NF、4NF、5NF、6NF MySQL属于关系型数据库，有空间上的浪费，其本身也是致力于节省存储空间，与范式所解决的问题不谋而合，在设计数据库的时候，会利用范式来指导设计，但不是强制规范。但是数据库不单是要解决空间问题，还要保证效率问题。范式只为解决空间问题，所以数据库的设计又不能完全按照范式的要求实现。一般情况下，满足3NF即可。 1NF：在设计表存储数据的时候，如果表中设计的字段存储的数据，在取出来使用之前，还需要额外的处理或拆分，那么该表的设计不满足第一范式。第一范式要求字段的数据具有原子性，不可再分。 2NF：在数据表设计的过程中，如果有复合主键（多字段主键），且表中有字段并不是由整个主键来确定，而是依赖主键中的某个字段（主键的部分）。即存在字段依赖主键的部分，称之为部分依赖。第二范式就是要解决表的设计不允许出现部分依赖。 3NF：理论上讲，应该一张表中的所有字段都直接依赖主键（逻辑主键：代表的是业务主键）。如果表设计中存在一个字段，并不直接依赖主键，而是通过某个非主键字段依赖，最终实现依赖主键。把这种不是直接依赖主键，而是依赖非主键字段的依赖关系称之为传递依赖。第三范式就是要解决传递依赖的问题。 逆规范化：在设计表的时候，如果一张表中有几个字段是需要从另外的表中去获取信息，理论上讲，的确可以获取到想要的数据，但是效率低一点。这时，会刻意的在某些表中，不去保存另外表的主键（逻辑主键），而是直接保存想要的数据信息。这样一来，在查询数据时，一张表可以直接提供数据，而不需要多表查询（效率低），但是会导致数据冗余增加。同时还需保证数据的一致性。 其他优化MySQL数据库配置优化这里就不说了。工作重点不在这一块，纯属了解了一下。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用动态代理实现一个简单的数据库连接池]]></title>
    <url>%2F2017%2F07%2F25%2Fjdbc-pool%2F</url>
    <content type="text"><![CDATA[明确一点：数据库连接是一个重量级的对象，每一个连接的建立是一个复杂且很消耗资源的事情。为了复用已经创建好的连接，出现了池技术。连接池、线程池、对象池等等。这里采用动态代理实现一个简单的数据库连接池。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import java.io.InputStream;import java.io.PrintWriter;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.SQLFeatureNotSupportedException;import java.util.LinkedList;import java.util.Properties;import java.util.logging.Logger;import javax.sql.DataSource;public class JdbcPool implements DataSource &#123; //使用LinkedList集合,会使用到大量的增删改查 private static LinkedList&lt;Connection&gt; list = new LinkedList&lt;Connection&gt;(); static&#123; try&#123; //读取数据库连接的必要配置 InputStream in = JdbcPool.class.getClassLoader().getResourceAsStream("db.properties"); Properties prop = new Properties(); prop.load(in); String driver= prop.getProperty("driver"); String url = prop.getProperty("url"); String username = prop.getProperty("username"); String password = prop.getProperty("password"); //加载驱动 Class.forName(driver); //找数据要多少个链接,就循环多少次 for(int i=0;i&lt;10;i++)&#123; Connection conn = DriverManager.getConnection(url, username, password); //把链接存入集合中 System.out.println("获取到了链接:"+conn); list.add(conn); &#125; &#125;catch (Exception e) &#123; throw new ExceptionInInitializerError(e); &#125; &#125; /* 1.写一个子类,覆盖close方法 2.写一个Connection的包装类,增强close方法 3.用动态代理,返回一个代理对象出去,拦截close方法的调用,对close方法进行增强 */ public Connection getConnection() throws SQLException &#123; //proxyConnection.commit() proxyConnection.rollback if(list.size()&gt;0)&#123; final Connection conn = list.removeFirst(); //myconnection.commit System.out.println("池大小是:" + list.size()); //使用动态代理 return (Connection) Proxy.newProxyInstance( JdbcPool.class.getClassLoader(), conn.getClass().getInterfaces(), new InvocationHandler()&#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if(!method.getName().equals("close"))&#123; return method.invoke(conn, args); &#125;else&#123; list.add(conn); System.out.println(conn + "被还给池了！！"); System.out.println("池大小为" + list.size()); return null; &#125; &#125; &#125;); &#125;else&#123; throw new RuntimeException("对不起，数据库忙"); &#125; &#125; @Override public PrintWriter getLogWriter() throws SQLException &#123; // TODO Auto-generated method stub return null; &#125; @Override public void setLogWriter(PrintWriter out) throws SQLException &#123; // TODO Auto-generated method stub &#125; @Override public void setLoginTimeout(int seconds) throws SQLException &#123; // TODO Auto-generated method stub &#125; @Override public int getLoginTimeout() throws SQLException &#123; // TODO Auto-generated method stub return 0; &#125; @Override public Logger getParentLogger() throws SQLFeatureNotSupportedException &#123; // TODO Auto-generated method stub return null; &#125; @Override public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException &#123; // TODO Auto-generated method stub return null; &#125; @Override public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException &#123; // TODO Auto-generated method stub return false; &#125; @Override public Connection getConnection(String username, String password) throws SQLException &#123; // TODO Auto-generated method stub return null; &#125;&#125; 原理DataSource接口是必须要实现的，上面那些未实现的方法这里不做说明，都是DataSource接口中需要实现的方法。JdbcPool在加载进内存时候，就已经找数据库获取了10个数据库连接。getConnection()获取数据库连接，返回的就是Connection的一个代理对象出去。最终要做的事情是，拦截对close()方法的处理，当发现调用的是close()方法时，并不去执行释放连接，而是把连接返回到了LinkedList集合里面去了。]]></content>
      <categories>
        <category>SQL</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL中InnoDB存储引擎的索引]]></title>
    <url>%2F2017%2F07%2F20%2Fmysql-index%2F</url>
    <content type="text"><![CDATA[索引是对数据库，表中一列或多列的值进行排序的一种结构，使用索引可提高数据库中特定数据的查询速度。索引是一个单独的、存储在磁盘上的数据库结构，它包含着对数据表中所有记录的引用指针。MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。索引的本质：索引是数据结构。 存储引擎支持的索引 MyISAM、InnoDB只支持BTree索引，Memory、Heap存储引擎可以支持Hash、BTree索引。 索引的分类 普通索引：MySQL中的基本索引类型，允许在定义所以的列中插入重复值和空值。 唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。主键索引是一种特殊的唯一索引，不允许有空值。 单列索引：一个索引只包含单个列，一个表可以有多个单列索引。 组合索引：在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。使用组合索引时遵循最左前缀集合。 全文索引：在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或TEXT类型的列上创建。只有MyISAM存储引擎支持全文索引。 空间索引：是对空间数据类型的字段建立的索引。创建空间索引的列，不允许有空值。只有MyISAM存储引擎支持空间索引。 索引的优点 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。 可以大大加快数据的查询速度，这也是创建索引的最主要原因。 索引的缺点 创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加。 索引需要占用磁盘空间，即物理空间。如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。 当对表中的数据进行增加、删除和修改时，索引也要动态的维护，降低了数据的维护速度。 InnoDB存储引擎的索引实现 InnoDB存储引擎使用B+Tree作为索引结构。在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。 InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键。如果没有显示指定主键，InnoDB会为每一行生成一个隐藏的6个字节的ROWID，并以此作为主键。《MySQL的存储引擎》一章所提到的。 在使用InnoDB存储引擎时，如果没有特别的需要，使用一个与业务无关的自增字段作为主键则是一个很好的选择。 聚集索引与非聚集索引 聚集索引表记录的排列顺序与索引的排列顺序一致，优点是查询速度快，因为一旦具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后。聚集索引的缺点是对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排，降低了执行速度。类似于数组。 非聚集索引指定了表中记录的逻辑顺序，但记录的物理顺序和索引的顺序不一致，聚集索引和非聚集索引都采用了B+Tree的结构。非聚集索引比聚集索引层次多，添加记录不会引起数据顺序的重组。类似于链表。 聚集索引和非聚集索引的区别 两者的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续。 聚集索引查询数据速度快，插入数据速度慢；非聚集索引反之。 索引的设计原则 索引并非越多越好，这里不再阐述原因。 避免对经常更新的表进行过多的索引，索引中的列尽可能少，而对经常用于查询的字段应该创建索引。 数据量小的表最好不要使用索引。查询花费的时间可能比遍历索引的时间还要短。 索引的选择性较低时，不应建立索引。 索引的选择性所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：Index Selectivity = Cardinality / #T显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。数据如下图：以dept_no做为建立索引的选择性：SELECT count(DISTINCT(dept_no))/count() AS Selectivity FROM employee;以e_no做为建立索引的选择性：SELECT count(DISTINCT(e_no))/count() AS Selectivity FROM employee;可以对比出，在e_no列上建立索引的选择性更高。当在e_no列上建立索引后，可以使用EXPLAIN语句查看索引是否正在使用。 EXPLAIN语句输出结果的各个行解释12345678select_type：指定所使用的SELECT查询类型。table：指定数据库读取的数据表名字，它们按照被读取的先后顺序排列。type：指定了本数据表与其他数据表之间的关联关系。可能的取值有：system、const、eq_ref、ref、range、index、All。possible_keys：在搜索数据记录时可选用的各个索引。key_len：给出索引按字节计算的长度，key_len数值越小，表示越快。ref：给出了关联关系中另一个数据表里的列名称。rows：执行这个查询时预计会从这个数据表中读取的数据行的个数。extra：其他与关联操作有关的信息。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用ReentrantReadWriteLock实现一个简单的缓存原理]]></title>
    <url>%2F2017%2F07%2F12%2Fcache-system%2F</url>
    <content type="text"><![CDATA[之前说过Lock，ReentrantReadWriteLock是Lock的实现类，可以获取读锁与写锁。这里用ReentrantReadWriteLock做一个简单的缓存系统原理实现。 代码跟注释如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class CacheSystem &#123; public static void main(String[] args) &#123; CacheUtil cacheUtil = new CacheUtil(); cacheUtil.getObject("1"); &#125;&#125;class CacheUtil &#123; // 本地存放缓存对象的集合 private Map&lt;String, Object&gt; cacheMap = new HashMap&lt;String, Object&gt;(); // 读写锁 private ReadWriteLock rwl = new ReentrantReadWriteLock(); // 获取数据 public Object getObject(String id) &#123; // 先上读锁 rwl.readLock().lock(); Object object = null; try &#123; object = cacheMap.get(id); if (null == object) &#123; // 发现缓存集合中没有数据，释放读锁 rwl.readLock().unlock(); // 上写锁 rwl.writeLock().lock(); try &#123; if (null == object) &#123; object = "往数据库查询出数据"; cacheMap.put(id, object); &#125; &#125; finally &#123; rwl.writeLock().unlock(); System.out.println("写锁释放了！"); &#125; // 重新上读锁 System.out.println("重新上读锁了！"); rwl.readLock().lock(); &#125; &#125; finally &#123; System.out.println("读锁释放了！"); rwl.readLock().unlock(); &#125; return object; &#125; // 更新数据 public void updateObject(Object obj) &#123; //获取更新对象的ID String id = "1";//伪代码obj.getId(); Object object = getObject(id); //缓存中有数据，避免数据不一致。清空缓存保存的数据 if(null != object)&#123; cacheMap.remove(id); &#125; System.out.println("更新数据库中数据"); &#125;&#125; mybatis中的缓存 一级缓存是SqlSession级别的缓存。在操作数据库时需要构造 sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。 二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。二级缓存是以namespace来划分的，一个namespace有一个二级缓存。 一级缓存工作原理查询时会创建一个唯一的Key。查询缓存Map中是否有对象更新时，执行删除缓存数据 一级缓存实现类PerpetualCache类 二级缓存需要单独配置，不做过多说明mybatis提供了Cache接口，可对接不同的缓存厂商。如redis、memcached、ehcache。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java中synchronized关键字与JDK1.5中显示Lock操作]]></title>
    <url>%2F2017%2F07%2F06%2Flock%2F</url>
    <content type="text"><![CDATA[本文主要是总结synchronized关键字与JDK1.5中Lock的操作。这里不谈论线程安全问题，线程安全问题是一个比较广而深的问题（volatile关键字、JMM内存模型、线程与主内存和工作内存的交互关系等）。同步使用的前提： 必须是两个或者两个以上的线程。 必须是多个线程使用同一个锁。 这时才可以称为这些线程被同步了。 synchronized关键字12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Resource &#123; public void methodOne(Object obj) &#123; System.out.println("进入methodOne()，" + obj); synchronized (obj) &#123; System.out .println(System.currentTimeMillis() + "-同步代码块：" + Thread.currentThread().getName() + "，锁=" + obj.toString()); sleep(); &#125; &#125; public synchronized void methodTwo(String str) &#123; System.out.println("进入methodTwo()，" + str); System.out.println(System.currentTimeMillis() + "-同步方法：" + Thread.currentThread().getName()); sleep(); &#125; public static synchronized void methodThree(String str) &#123; System.out.println("进入methodThree()，" + str); System.out.println(System.currentTimeMillis() + "-静态同步方法：" + Thread.currentThread().getName()); sleep(); &#125; private static void sleep() &#123; try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Thread1 extends Thread &#123; private Resource res; public Thread1(Resource res) &#123; this.res = res; &#125; public void run() &#123; res.methodOne("lockA"); &#125;&#125;class Thread2 extends Thread &#123; private Resource res; public Thread2(Resource res) &#123; this.res = res; &#125; public void run() &#123; res.methodOne("lockA"); &#125;&#125;public class TestMain &#123; public static void main(String[] args) &#123; Resource r1 = new Resource(); //Resource r2 = new Resource(); Thread1 t1 = new Thread1(r1); Thread2 t2 = new Thread2(r1); t1.start(); t2.start(); &#125;&#125; 上面一段简单的代码，分别来说明synchronized关键字加在代码片段中、加在方法声明上、加在静态方法声明上，它所使用的锁对象是哪些。 synchronized关键字加在代码片段中Thread1和Thread2使用的是同一个锁对象（lockA）。字符串初始化时存放在方法区的字符串常量池。“lockA”跟new String(“lockA”)，则是两个不同的对象。这里不做过多说明。Thread1和Thread2发生了互斥，说明同步代码块的关键是synchronized关键字括号中的锁对象，可以是任意对象。当锁对象不是同一对象时，synchronized代码块则不会发生互斥。 synchronized关键字加在方法声明上方法需要被对象调用，方法都有一个所属对象的引用，就是this。同步方法使用的锁就是this锁。再来看下面另两幅图。上图中，使用的是不同锁，所以没有发生互斥。当把res对象自己传递给methodOne()时，发现同步代码块跟同步方法开始互斥了。 结论同步方法使用的锁就是this锁。 synchronized关键字加在静态方法声明上再之前的对象初始化过程中提过，静态成员（静态方法与静态属性，专业说话叫类变量）和普通方法也会随着类的加载而被加载。this关键字表示一个对象引用。所以静态同步方法肯定不是用的this锁对象。运行，methodThree()发生了互斥。换种方式。methodOne()采用Resource的字节码对象作为锁对象。与methodThree()发生了互斥。 结论之前说过一个类只有一份字节码文件，在加载进内存时，一个类只有一个字节码文件对象。静态同步方法使用的锁是该方法所在类的字节码文件对象。（类名.class跟对象.getClass()是一码事，都是获取当前类的字节码对象） 死锁 原理：同步中嵌套同步，彼此拿着需要的锁不放。1234567891011121314151617181920212223242526272829303132333435class Lock implements Runnable&#123; private boolean flag; Lock(boolean flag)&#123; this.flag=flag; &#125; public void run() &#123; if(flag)&#123; synchronized (Mylock.locka) &#123; System.out.println("if..locka"); synchronized (Mylock.lockb) &#123; System.out.println("if..lockb"); &#125; &#125; &#125; else&#123; synchronized (Mylock.lockb) &#123; System.out.println("else..lockb"); synchronized (Mylock.locka) &#123; System.out.println("else..locka"); &#125; &#125; &#125; &#125;&#125;class Mylock&#123; static Object locka=new Object(); static Object lockb=new Object();&#125;public class Deadlock &#123; public static void main(String[] args)&#123; Thread t1=new Thread(new Lock(true)); Thread t2=new Thread(new Lock(false)); t1.start(); t2.start(); &#125;&#125; Lock显示锁对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class Resource &#123; private Lock lock = new ReentrantLock(); public void set(String name) &#123; lock.lock(); try &#123; System.out.println(System.currentTimeMillis() + "，" + Thread.currentThread().getName() + "，" + name); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; finally &#123; // 释放锁的操作一定要执行 lock.unlock(); &#125; &#125;&#125;class Producer implements Runnable &#123; private Resource res; public Producer(Resource res) &#123; this.res = res; &#125; public void run() &#123; res.set("张三"); &#125;&#125;class Consumer implements Runnable &#123; private Resource res; public Consumer(Resource res) &#123; this.res = res; &#125; public void run() &#123; res.set("李四"); &#125;&#125;public class TestMain &#123; public static void main(String[] args) &#123; Resource r = new Resource(); Producer pro = new Producer(r); Consumer con = new Consumer(r); Thread t1 = new Thread(pro); Thread t2 = new Thread(con); t1.start(); t2.start(); &#125;&#125; 运行一互斥，正常释放锁，正常运行。 运行二互斥，Thread-0未释放锁，Thread-1则一直阻塞。 synchronized与Lock的区别 Lock支持细粒度的锁控制，可以进行读写的分离。synchronized很难实现。 Lock是无阻塞锁。所谓无阻塞锁，是对于线程状态而言的。使用Lock访问临界区资源时，处于等待中的线程，它的线程状态是等待状态。synchronized是阻塞锁。所谓阻塞锁，是指处于等待中的线程，其状态是阻塞状态。 Lock可实现公平锁，synchronized只能是非公平锁。公平锁，是指对于处于等待访问临界资源的所有线程来说的，类似排队买票，先来先买，公平锁也就是处于最先等待的线程最先拿到锁。非公平锁，采用抢占式对临界资源进行访问，所有处于等待中的线程，谁先抢到锁，谁先执行。 Lock是通过编码实现对临界区资源的访问，synchronized是在运行期由JVM解释的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[装饰、代理设计模式]]></title>
    <url>%2F2017%2F07%2F01%2Fdesign-pattern%2F</url>
    <content type="text"><![CDATA[之前在说单例设计模式的时候提到过，设计模式是针对问题最有效的解决方法。这里再回顾一下自己熟悉的装饰、代理、工厂、策略、观察者设计模式。先说装饰、代理设计模式。 装饰设计模式当想要对已有的对象进行功能增强时，可以定义类，将已有对象传入，基于已有对象的功能，提供加强功能。那么自定义的该类称为装饰类。装饰类。通常会通过构造方法接收被装饰的对象，并基于被装饰对象的功能，提供更强的功能。装饰模式比继承要灵活，避免了继承体系的臃肿。而且降低了类与类之间的关系。装饰类因为只是增强已有对象，具备的功能和已有对象是相同的，只不过提供了更强的功能，所以装饰类和被装饰类通常属于一个体系。 代码123456789101112131415161718192021222324252627282930313233//装饰设计模式public class MyBufferedReader &#123; private Reader r; MyBufferedReader(Reader r) &#123; this.r = r; &#125; public String MyReaderLine() throws IOException &#123; // 定义一个临时容器,原BufferedReader封装的是字符数组 StringBuilder sb = new StringBuilder(); int ch = 0; while ((ch = r.read()) != -1) &#123; if (ch == '\r') continue; if (ch == '\n') return sb.toString(); else sb.append((char) ch); &#125; if (sb.length() != 0) return sb.toString(); return null; &#125; public int read(char[] cbuf, int off, int len) throws IOException &#123; return r.read(cbuf, off, len); &#125; public void close() throws IOException &#123; r.close(); &#125;&#125; 增强Reader，增强一个MyReaderLine（读一行）的方法，而其他的方法还是调用原来对象的方法。工作中常用到可能是下图这种情况，有人写了一个工具类方法，但是功能不够强或比较繁琐。那我们不能直接去改这个工具类方法，因为这个工具类方法可能有很多地方进行了调用。要么写个子类进行覆盖，要么进行增强。这也是装饰的一种手法。 当一个Java对象方法不够用的时候，有如下方法解决此问题。 写一个子类，覆盖某个方法。如果父类已经封装了信息，不再建议使用此方法。 写一个此类的包装类，增强某个方法。当包装方式比较复杂时，使用代理模式。 使用代理模式，返回一个代理对象出去，拦截某个方法的调用，并对其进行增强。 代理模式代理模式有点类似明星与经纪人一样。这里主要讲动态代理。某个房地产公司想请某明星代言，直接找该明星的经纪人谈具体的细节，谈好之后，实际的代言是由明星去做。这是一个思路，那我们来看怎么实现。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//代理接口 public interface Subject &#123; String sing(String name); String dance(String name);&#125;//明星public class Star implements Subject &#123; public String sing(String singName) &#123; System.out.println("Star sing()，唱" + singName + "歌!"); return "飞吻!"; &#125; public String dance(String danceName) &#123; System.out.println("Star dance()，跳" + danceName + "舞!"); return "多谢老板!"; &#125;&#125;//明星的经纪人public class StarProxy &#123; private Subject star = new Star(); public Subject getProxy()&#123; return (Subject) Proxy.newProxyInstance( StarProxy.class.getClassLoader(), star.getClass().getInterfaces(), new InvocationHandler() &#123; /** * proxy:把代理对象自己传递进来 * method:把代理对象当前调用的方法传递进来 * args:把方法参数传递进来 **/ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 编码指定返回代理对象的干的工作 if(method.getName().equals("sing"))&#123; //执行业务逻辑处理 System.out.println("StarProxy，搞一万块钱来"); return method.invoke(star, args); &#125; if(method.getName().equals("dance"))&#123; //执行业务逻辑处理 System.out.println("StarProxy，搞两万块钱来"); return method.invoke(star, args); &#125; return null; &#125; &#125;); &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; StarProxy proxy = new StarProxy(); Subject s = proxy.getProxy(); System.out.println(s.dance("拉丁")); &#125;&#125; 运行如下：Proxy类的newProxyInstance()是JDK自带的动态代理，产生代理对象，基于接口进行代理，拦截对真实对象的访问。代理对象需要具备与真实对象相同的行为，代理对象最终还是找真实对象实现具体的行为。newProxyInstance()方法接收三个参数，第一个是类加载器，第二个是哪个接口，第三个是干什么行为。如果一个类没有接口，要使用动态代理，需要使用CGLib。spring在AOP中两种进行了采用。JDK返回出的代理对象是基于接口生成的。CGLib返回出的代理对象是基于子类生成的，所以类不能被final修饰。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java对象初始化的过程]]></title>
    <url>%2F2017%2F06%2F27%2Fobjectinit%2F</url>
    <content type="text"><![CDATA[从学Java开始，就一直牢牢的记住着一句话。”基础决定了你在这条道路上能走多远。”，虽然当时不是很明白。但庆幸的是一直都放在心里。再温习一下Java对象初始化的过程，把这种理解性的知识，用图文的方式去描述出来。 一个很简单的Java类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Student &#123; private String name = "haha"; private int age; private static String country = "cn"; //无参构造函数 Student() &#123; &#125; //有参构造函数 Student(String name, int age) &#123; System.out.println("有参构造函数：" + name + ".." + age); this.name = name; this.age = age; &#125; //构造代码块 &#123; System.out.println("构造代码块：" + name + ".." + age); &#125; //静态代码块 static &#123; System.out.println("静态代码块：static.."); &#125; public void setName(String name) &#123; this.name = name; &#125; public void speak() &#123; System.out.println(this.name + "..." + this.age); &#125; public void listen() &#123; speak(); &#125; public static void showCountry() &#123; System.out.println("country=" + country); method(); &#125; public static void method() &#123; System.out.println("method run"); &#125;&#125; Student s = new Student(“zhangsan”, 19);上图中，在我们使用的时候，该句话都做了什么事情？（只谈论内存中的堆、栈区域，不涉及其他区域） 文字结论 当虚拟机读取到这句话的时候，首先看等号的左边。Student s，s是一个变量，虚拟机会在栈内存中开辟空间，存放s这个变量。 当读取到等号的右边new Student(“zhangsan”, 19)。因为用到了Student类，虚拟机会编译Student.java文件，生成Student.class文件。俗称字节码文件，一个类只有一份字节码文件。（请自行区别.java文件跟类的概念） 会把Student这个类的字节码从硬盘加载进内存。这里提一嘴，JVM中的类加载器Classloader。 如果有静态代码块，就会随着类的加载而执行。静态成员（静态方法与静态属性，专业说话叫类变量）和普通方法也会随着类的加载而被加载。 在堆内存中开辟空间，并分配内存地址。（内存地址是十六进制数） 在堆内存中建立对象特有属性，并同时对特有属性进行默认初始化。 对对象属性进行显示初始化。 执行构造代码块，对所有对象进行初始化。 执行对应的构造函数，对对象进行初始化。 将内存地址赋给栈内存中的s变量。（栈内存中的变量指向堆内存中的变量，这就是Java中的指针） 静态成员存放在方法区，在内存中只有一份。随着类的的加载而被加载，优先于对象存在，被所有的对象所共享，可以被类名直接调用，也可以被对象调用。showCountry()方法中调用method()，就是直接省略了（Student.）同样的，listen()方法中调用speak()，就是直接省略了（this.） 如理解的描述有错，请务必告知。谢谢！对象初始化的过程远比本人用文字描述出来的复杂。Classloader、内存空间分配策略、内存模型等一系列问题。本人只是用文字，简单并肤浅的去描述了这么一个过程。便于更好的理解与记忆。对JVM感兴趣的，可以膜拜《深入理解Java虚拟机》一书。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[阻塞队列的实现原理]]></title>
    <url>%2F2017%2F06%2F18%2Fblocking-queue%2F</url>
    <content type="text"><![CDATA[在这里贴一下有界阻塞队列的实现代码，总结一下自己的理解。底层用的是数组，其实就是一个循环队列。适合对并发时的数据处理。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package thread;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class BoundedBuffer &#123; //锁对象 private final Lock lock = new ReentrantLock(); private final Condition notFull = lock.newCondition(); private final Condition notEmpty = lock.newCondition(); //阻塞队列最大容量值为100 private final Object[] items = new Object[100]; private int putptr, takeptr, count; //缓冲存放对象 public void put(Object x) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length)&#123; //满了，进行等待 notFull.await(); &#125; items[putptr] = x; if (++putptr == items.length)&#123; //存放位置的指针要超过容量值了，则回到原点 putptr = 0; &#125; ++count; //发信号，让空的走 notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; public Object take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0)&#123; //空了，进行等待。队列已经取完了。 notEmpty.await(); &#125; Object x = items[takeptr]; if (++takeptr == items.length)&#123; //取出位置的指针要超过容量值了，则回到原点 takeptr = 0; &#125; --count; //发信号，让满的走 notFull.signal(); return x; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 测试这里取两次，第一次就取完了，第二次就在等待放入数据。 结论举一个简单的栗子说明，假设服务器或对外提供的接口并发的最高峰值访问是60，这时突然有80个访问请求需要处理。阻塞队列的应用场景就出现了。主要的作用与目的，就是起到缓冲的作用。存一个，取一个。在代码实现时，判断队列是否已经放满了和判断队列是否已经取空了时用了while，这是一个小小的细节。在等待 Condition 时，允许发生“虚假唤醒”，这通常作为对基础平台语义的让步。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java的List、Set、Map容器]]></title>
    <url>%2F2017%2F06%2F18%2Flist-set-map%2F</url>
    <content type="text"><![CDATA[数组的特点 数据多了用对象存储，对象多了就用数组或集合存储。使用容器的最基本规则。 数组的长度必须事先指定，且一旦定义就不能再更改。 数组的存储的数据类型是固定的类型，单一类型数据的存储。 数组的内存分配，一次性分配一片连续的内存空间。连续的内存空间有多大，就在于数组的长度有多长。 为什么会出现这么多的容器呢？因为每一个容器对数据的存储方式都有不同，这个存储方式称之为：数据结构。 List中常用的容器该容器体系存放元素是有序的，元素可以重复。因为该集合体系有索引。List集合判断元素是否相同，依据的是元素的equals()方法。如果需要依据自己的条件进行判断是否为同相同元素，则需要重写equals()方法。 ArrayList 底层使用数组结构。elementData就是该集合存放数据的地方。分配的内存地址空间是连续的一片。 特点：查询速度很快。但是增删稍慢。线程不安全。拿着角标，即可获取到元素。就类似与现实生活中的门牌号。”去找到小明家”，这么多叫小明的，怎么找？”去找到小明家，他住XX街5号”。在角标4的位子插入一个新元素，意味该角标位后面的所有元素都需要挪动一下。假设集合的容量很大，1000、10000、100000或者1000000（当然不能超过int的最大值），就这一个简单的操作，对内存的消耗是非常大的。删除也是同理。 自动扩容，每次都是把原来的数组复制进一个新数组中，新数组的长度增长量是原来的size的50%。看一下ArrayList的源码：自动扩容是发生在添加的时候。容量为当前size+1modCount这里不做详细说明，ConcurrentModificationException异常产生的原因就是因为它。如果size+1减去当前元素数组的长度大于0，则表示需要扩容。第一个红线，新的容量为旧的容量加上旧的容量值右移一位。int数值的二进制右移一位，就是原来数值的一半。所以，扩容的增长量是原来的size的50%。第二个红线，调用Arrays.copyOf()方法。如下图，在原数组的基础上，新增一个数组。LinkedList 底层使用链表结构，双链表。分配的内存地址空间是可以是碎片化空间。 特点：增删很快，查询很慢，线程不安全。增加：让最后一个元素的next记录住当前新增元素的空间地址，并当前新增元素的prev记录上一个元素，last为当前元素地址。删除也是同理，直接让上一个元素的next为null，last为上一个元素地址。上图，get(int index)和remove(int index)方法中，折半来进行顺序查找元素。ListIteratorList集合特有的迭代器。在迭代时，不可以通过集合对象的方法操作集合中的元素。因为会发生ConcurrentModificationException异常。所以，在迭代器时，只能用迭代器的方式操作元素，可是Iterator方法是有限的，只能对元素进行判断，取出，删除的操作，如果想要其他的操作如添加，修改等，就需要使用其子接口，ListIterator。该接口只能通过List集合的listIterator方法获取。实现简单的队列123456789101112131415161718192021222324252627class MyQueue &#123; private LinkedList&lt;Object&gt; link; MyQueue() &#123; link = new LinkedList&lt;Object&gt;(); &#125; public void myAdd(Object obj) &#123; link.offerFirst(obj); &#125; public Object myGet() &#123; return link.pollLast(); &#125; public boolean isNull() &#123; return link.isEmpty(); &#125;&#125;public class LinkedListTest &#123; public static void main(String[] args) &#123; MyQueue mq = new MyQueue(); mq.myAdd("java01"); mq.myAdd("java02"); mq.myAdd("java03"); mq.myAdd("java04"); while (!mq.isNull()) &#123; System.out.println(mq.myGet()); &#125; &#125;&#125; Set中常用的容器元素是无序(存入和取出的顺序不一定一致)，元素不可以重复。底层都是使用Map集合存储元素。 HashSet 底层数据结构是哈希表，使用HashMap存储元素，只使用了HashMap的Key部分，未使用Value部分。是线程不安全的。 HashSet是如何保证元素唯一性的呢？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Person &#123; private String name; private int age; Person() &#123; &#125; Person1(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public boolean equals(Object obj) &#123; if (!(obj instanceof Person1)) &#123; return false; &#125; Person p = (Person) obj; System.out.println(this.name + "-equals-" + p.name); return this.name.equals(p.name) &amp;&amp; this.age == p.age; &#125; public int hashCode() &#123; // System.out.println(this.name+"...hashCode"); return name.hashCode() + age * 27; //return age * 27; &#125;&#125;public class HashSetTest &#123; public static void main(String[] args) &#123; HashSet&lt;Person&gt; hs = new HashSet&lt;Person&gt;(); hs.add(new Person("王五", 21)); hs.add(new Person("张三", 22)); hs.add(new Person("李四", 19)); hs.add(new Person("王五", 22)); for (Iterator&lt;Person&gt; it = hs.iterator(); it.hasNext();) &#123; Person p = it.next(); System.out.println(p.getName() + "，" + p.getAge()); &#125; &#125;&#125; hashCode值采用name.hashCode() + age * 27 hashCode值采用age * 27，age相同就会进行比较，因最终equals不为true，视为不同元素。 hashCode值采用age * 27，age相同就会进行比较，比较了两次，equals为true，视为相同元素，不存入。 结论HashSet是通过元素的两个方法，hashCode和equals来完成。如果元素的HashCode值相同，才会判断equals是否为true。如果元素的hashcode值不同，不会调用equals。注意,对于判断元素是否存在，以及删除等操作，依赖的方法是元素的hashcode和equals方法。 TreeSet 底层数据结构是二叉排序树，使用TreeMap存储元素。是线程不安全的。使用TreeMap中的K保存数据，V是一个常量Object对象。 特点：可以对集合内的元素进行排序。 默认的排序规则是：按自然排序（左小右大）。下图是put方法中的一段代码。 排序重点，比较器或比较接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//如果想让TreeSet拥有其他的排序方式，有两钟方式。public class TreeSetDemo &#123; public static void main(String[] args) &#123; //TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(); //第二种方式：让集合具备比较性，将比较器对象作为参数传递给TreeSet集合的构造函数 TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new MyComparator()); ts.add(new Student("王五", 21)); ts.add(new Student("李四", 20)); ts.add(new Student("张三", 23)); ts.add(new Student("王五", 21)); ts.add(new Student("马二", 19)); ts.add(new Student("李四", 19)); for (Iterator&lt;Student&gt; it = ts.iterator(); it.hasNext();) &#123; Student s = it.next(); System.out.println(s.getName() + "，" + s.getAge()); &#125; &#125;&#125;//第一种方式：让Student类实现Comparable接口，重写compareTo方法。强制让学生具备可比性class Student implements Comparable&lt;Student&gt; &#123; private String name; private int age; Student() &#123; &#125; Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; //重写compareTo()方法，自行定义比较规则 public int compareTo(Student o) &#123; if (this.age &gt; o.age) return 1; if (this.age == o.age) &#123; // 当主要条件满足时，判断次要条件 return this.name.compareTo(o.name); &#125; return -1; &#125;&#125;//自定义比较器，实现Comparator接口class MyComparator implements Comparator&lt;Student&gt; &#123; public int compare(Student o1, Student o2) &#123; //自行定义比较规则 int num = o1.getName().compareTo(o2.getName()); if (num == 0) // 对象包装类调用compareTo()方法，判断次要条件 return new Integer(o1.getAge()).compareTo(new Integer(o2.getAge())); return num; &#125;&#125; TreeSet保证元素唯一性的依据就是compareTo()方法的return值。大小判断的依据也是该方法的返回值。正数代表大，负数代表小，0则表示是相同元素。1234567891011//使用匿名内部类的方式，传递比较器TreeSet&lt;String&gt; ts = new TreeSet&lt;String&gt;(new Comparator&lt;Student&gt;()&#123; public int compare(Student o1, Student o2) &#123; //自行定义比较规则 int num = o1.getName().compareTo(o2.getName()); if (num == 0) // 对象包装类调用compareTo()方法，判断次要条件 return new Integer(o1.getAge()).compareTo(new Integer(o2.getAge())); return num; &#125;&#125;); Map中常用的容器上面已经说过。Set集合底层就是使用Map集合存储。Map集合被使用是因为具备映射关系。Map集合中，如果键相同，就会出现新值覆盖旧值。 Map集合的取值原理：将Map集合转成Set集合，再通过迭代器取出。取值的两种方式： entrySet()：返回值类型为Set]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客站点解密]]></title>
    <url>%2F2017%2F06%2F03%2Fdecrypt-blog%2F</url>
    <content type="text"><![CDATA[对搭建个人博客站点的步骤进行详细回顾，并记录。个人喜欢图文并茂。总结是检验自己的学习效果，并进行巩固。 系统环境配置 之前说过个人博客采用node.js+hexo+github搭建。要使用hexo，需要在你的系统中支持node.js以及Git，如果还没有，那就需要安装。 安装node.js 下载与安装地址：http://www.runoob.com/nodejs/nodejs-install-setup.html 请根据自己操作系统的位数进行下载，这里不在阐述。 检验node.js是否安装好，如下图： 安装Git 下载与安装地址：https://git-scm.com/download/ 请根据自己操作系统的位数进行下载，这里不在阐述。 检验Git是否安装好，如下图： 安装hexo安装好Git后，右键点击Git Bash，进入本地Git控制台。1234567$ cd d:/hexo # 可自行安装到任意目录$ npm install hexo-cli -g # 使用包管理工具npm安装hexo，-g是全局安装$ hexo init blog # 初始化到blog目录中，可任意选择$ cd blog # 进入blog目录$ npm install # 本地安装$ hexo g # 或者hexo generate，会在当前路径下生成public文件夹$ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看 这里有必要提下Hexo常用的几个命令：123$ hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹$ hexo server (hexo s) 启动本地web服务，用于博客的预览$ hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台） 常用简写1234$ hexo n == hexo new$ hexo g == hexo generate$ hexo s == hexo server$ hexo d == hexo deploy 现在打开http://localhost:4000/已经可以看到一篇内置的blog了。 安装所用的本地环境如下：(可以通过Git控制台输入hexo -v查看) hexo主题设置这里以主题yilia为例进行说明。可以百度搜索hexo主题，有很多。 安装主题12$ hexo clean$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 启用主题修改blog目录下的_config.yml配置文件中的theme属性，将其设置为yilia。 更新主题12345$ cd d:/hexo/blog/themes/yilia$ git pull # # 取回远程仓库的变化，并与本地分支合并$ cd d:/hexo/blog$ hexo g # 生成新的静态文件$ hexo s # 启动本地web服务器 现在打开http://localhost:4000/，会看已经应用了一个新的主题。 GitHub注册GitHub地址：http://www.github.com/注册你的 username 和邮箱，邮箱十分重要，GitHub 上很多通知都是通过邮箱发送。 配置和使用 GitHub 登录GitHub，跳过引导页。点击Start a project 入下图示例：以.github.io结尾仓库。红色感叹号，是因为我的仓库已经存在同名项目了。不存在会显示绿色打钩图标 新建的仓库，需要有一次提交记录。红框部分就是一个示例，在Git控制台进行输入。输入之前先让本地 git 项目与远程的 GitHub 建立联系。 配置 SSH keys检查 SSH keys的设置1$ cd ~/.ssh # 检查本机的ssh密钥 如果提示：No such file or directory，说明你是第一次使用 git。如果有把.ssh文件夹里的文件先删掉。.ssh路径为：’C:\Users\your_user_directory\’，例如我的’C:\Users\DELL\’ 生成新的 SSH Key：12345$ ssh-keygen -t rsa -C &quot;邮箱地址@youremail.com&quot; # GitHub注册的邮箱地址，-C为大写的C$ Generating public/private rsa key pair. # 采用非对称加密算法RSA生成公钥与私钥$ Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): # 回车就好$ Enter passphrase (empty for no passphrase): # 加盐处理，输入加密串$ Enter same passphrase again: # 加盐处理，再次输入加密串 SSH key设置成功界面： 添加 SSH Key 到 GitHub 打开本地 id_rsa.pub 文件（参考地址 C:\Users\DELL.ssh\id_rsa.pub）。此文件里面内容为刚才生成的密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。 登陆 GitHub 账号。点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys 把本地生成的密钥复制到里面（ key 文本框中）， 点击 add key 就ok了 使用Git控制台进行第一次提交新建一个文件夹，右键点击Git Bash，进入本地Git控制台。123456$ echo &quot;# test&quot; &gt;&gt; README.md$ git init$ git add README.md$ git commit -m &quot;first commit&quot;$ git remote add origin https://github.com/denghuashan/denghuashan.git.io.git$ git push -u origin master 此时会要求输入username和password 返回GitHub仓库F5刷新一下 点击右上角Fork这时，可以通过链接http://denghuashan.github.io/访问了。（现在还没有内容，别着急） 部署hexo到Github这是很关键的一步，把在本地web环境下预览到的博客部署到github上，然后就可以直接通过http://denghuashan.github.io/访问了。12$ cd d:/hexo/blog$ git clone https://github.com/denghuashan/denghuashan.github.io.git .deploy/denghuashan.github.io 将之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码。 创建一个deploy脚本文件123456789$ hexo generate # 生成最新的静态文件$ cp -R public/* .deploy/denghuashan.github.io # 拷贝public文件夹下的文件到本地仓库中去$ cd .deploy/denghuashan.github.io$ git add . # 添加到暂存区$ git commit -m “update” # 说明为update$ git push origin master # 推送本地分支到远程仓库master分支，输入username和password$ # 在d:/hexo/blog新建一个deploy.sh的文件，保存上面的指令。（shell脚本）下次推送到仓库的时候，直接在Git控制台启用。$ cd d:/hexo/blog$ sh deploy.sh 再访问http://denghuashan.github.io，就会看到hexo的web页面了。 blog目录 各文件夹及文件的作用 .deploy：本地仓库 node_modules：nodejs对hexo的支持，不要删除 public：hexo生成的静态文件 source：类似那个webapp目录，该目录下的_posts文件夹就是存放文章的。Markdown文件，方便博客的编写与编辑。 themes：主题文件存放处 blog目录下_config.yml文件配置说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: DreamMaker-HS # 个人博客的标题。html中head标签中的titlesubtitle: 勤思善问，可敌良师益友。# 子标题description: 博学而笃志，切问而静思.! # 描述author: HuaShan # 作者名language: timezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://dhsmp.com # 独立域名root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format ## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia # 主题，可以更改主题。默认是landscape# Deployment## Docs: https://hexo.io/docs/deployment.html# 下面的配置需要添加deploy: # 部署` type:github # 部署类型` repository:https://github.com/denghuashan/denghuashan.github.io.git # 仓库地址` branch:master # 分支` 绑定独立域名123456$ cd d:/hexo/blog/source/$ touch CNAME$ vim CNAME # 输入你的域名$ git add CNAME$ git commit -m &quot;add CNAME&quot;$ sh deploy.sh # 重新生成并提交 我是在阿里云上买的域名，操作基本是一样的。获取GitHub的IP地址，进入source目录下，添加CNAME文件。在域名注册提供商那里配置DNS解析。 其他高级技巧 上面已经可以用独立域名进行访问了，其他的一些修改。在themes/(当前使用主题)/_config.yml文件进行修改配置。这里不在阐述。其他的一些特性，在这里只会提到，至于如何使用，请自行摸索。 采用Markdown进行文章的编辑与编写 使用的图床为七牛云存储 + 简易图床。https://portal.qiniu.com/signup?code=3lmipeyx3j782，点这个连接注册，可以给我增加存储空间。谢谢了。 添加404公益页面，推荐使用腾讯公益404。http://www.qq.com/404/ 还可以添加一些其他的插件，如统计访问量、文章字数统计、文章评论与回复、打分，等等。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记住让自己心动时刻]]></title>
    <url>%2F2017%2F06%2F02%2Ffirst-article%2F</url>
    <content type="text"><![CDATA[随想 一直都想建立自己的个人博客站点。只是在近两个月付诸了行动。今天也能算是一个里程碑。顺便记录一下自己的感想，以及对自我的计划。把以前的笔记再总结分享出来。 每天晚上8点到10点，都是自己的学习时间。看书、敲一些跟工作无关的代码。这事，每天都在坚持。不打算放弃它。 一个大目标，我希望在十年后能成为一个软件开发的小牛，让自己能高效而简洁地解决编程问题，但是不受企业低效的管理束缚且有能满足高质量生活的收入水平。 2017年，继续补充并巩固好编程基础理论知识、Java语言核心特性。同时补习自考本科的文化知识。每个月定时的跟踪和调整这个小目标，激励自己前行。 2019年，顺利自考本科通过。满足人生的一大憾事。（人生最痛苦的是，一辈子在后悔中度过） 做一个终身学习者，希望个人博客的文章数能在50岁的时候足够修订成一本散文随记。 个人博客采用node.js+hexo+github搭建的，如有兴趣可以自行百度或发送邮件给我。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>